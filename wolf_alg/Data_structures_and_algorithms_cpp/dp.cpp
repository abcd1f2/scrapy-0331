#include <iostream>
using namespace std;

/**
    * No1.塔树选择和最大问题
    *
    * 一个高度为N的由正整数组成的三角形，从上走到下，求经过的数字和的最大值。
    * 每次只能走到下一层相邻的数上，例如从第3层的6向下走，只能走到第4层的2或9上。
    *      5
    *     8 4
    *    3 6 9
    *   7 2 9 5
    * 例子中的最优方案是：5 + 8 + 6 + 9 = 28
    *
    * 输入：符合塔树的二维数组。
    * 输出：经过的最大值。
    *
    * 分析：
    * dp(x,y)：表示第x层第y个数所经过的最大值。
    * dp(x,y)={
    *      array[x][y]  当x==0;
    *      dp[x-1,y] + array[x][y] 当x!=0,y=0;
    *      dp[x-1,y-1] + array[x][y] 当x!=0,y=x;
    *      max(dp[x-1,y-1],dp[x-1,y]) + array[x][y] 当x!=0;
    * }
*/
void func1()
{

}


int main()
{
    return 0;
}
