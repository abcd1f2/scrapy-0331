## media-audio webrtc aec
- **概述：**
>       webRTC的回声消除算法主要包括以下几个重要模块：
>           1、回声时延估计
>               延时估计模块采用自相关技术
>           2、NLMS（归一化最小均方自适应算法）
>               nlms 模块开源算法只用了12block
>           3、NLP（非线性滤波）
>               nlp 部分使用的是互相干技术
>           4、CNG（舒适噪声产生）
>           一般的aec算法还包括双端检测(DT)
>

- **webRTC AEC算法应用场景：**
>       webrtc AEC算法是属于分段快频域自适应滤波算法，Partioned block frequeney domain adaPtive filter(PBFDAF)
>       使用该AEC算法要注意两点：
>           1、延时要小
>               因为算法默认滤波器长度是分为12块，每块64点，按照8000采样率，也就是12*8ms=96ms的数据，而且超过这个长度是处理不了的
>           2、延时抖动要小
>               因为算法是默认10块也计算一次参考数据的位置（即滤波器能量最大的那一块），所以如果抖动很大的话找参考数据时不准确的，这样回声就消除不掉了
>
>

- **回声消除步骤：**
>       回声消除处理过程：
>           1、房间A接收到房间B的声音，声音被采样，这个采样被称为回声消除参考
>           2、随后声音被送到房间A的音响和声学回声消除器中
>           3、房间B和房间A的声音一起被送到房间A的话筒中
>           4、声音被送到声学回声消除器中，与原始采用进程比较，移除房间B的声音
>

- **回声消除数学原理：**
>       主要是找到远端回声和近端声音的边界
>       远端的声音信号和回声是相关的，可以用一个函数F(x)来表示，所以自适应滤波器就是为了找到最佳的函数F(x)，如下，
>           fe=F(fs)  其中，fs远端信号，fe远端回音
>       如果能求解这个函数，就可以根据远端声音和远端回音之间的相关性进行建模，这个模型是对远端回音的模拟。
>       自适应滤波器收敛后得到的就是需要求解的回声馈路函数
>       等到这个模型稳定时，输入远端声音信号 fs，就可以输出高度接近远端回声的信号 fe。通过滤波器生成反相的信号，和采集到的声音信号进行叠加，就可以把回声信号消除掉。这就是回声消除AEC的基本原理。
>

- **静音、单讲和双讲：**
>       虽然实时语音的通话是双工模式，但是可以分为不同的情形：静音、单讲和双讲。针对不同的情形要采取不同的回声消除策略。
>       1、静音：
>           在语音段才需要做回声消除，在非语音段不会有回声，不需要做回声消除，甚至不需要发送语音信息，从而可以降低码率，节约带宽成本
>           因此，准确探测语音活动十分重要。语音的探测算法叫 VAD(Voice Activity Detection）
>           我们是利用基音周期实现VAD，有效地提高VAD判断的准确性，避免将非语音段误判为语音段（仅做参考）
>
>       2、单讲：
>           只有远端说话的情形
>           由于只有远端说话，从麦克风采集进来的语音信号只包含远端的回声，而不包含近端的语音。单讲情形下的回声消除相对比较容易处理，可以采取比较激进的处理策略
>           如果确定单讲是高概率事件的情况下，可以直接地把所有语音信号都干掉，然后适当地填充舒适噪音。
>           一般来说，在单讲情形下，用线性自适应滤波器跟踪回声馈路，可以很好地消除回声，大概能够抑制掉 18dB 的回声
>
>       3、双讲：
>           多方同时说话的情形
>           由于有多方同时说话，从麦克风采集进来的语音信号就包含了远端的回声和近端的语音，两者混合在一起。双讲情形下的回声消除就十分困难：
>               一方面要保护近端的语音信号不被损伤，另外一方面还要尽量地把回声消除干净。
>           一般来说：
>               1、在远端回声比近端语音要高大概 6dB~8dB 的情况下，如果要把远端回声消除干净，那么肯定会或多或少地损伤到近端语音。
>               2、如果远端回声比近端语音要高出 18dB 以上，比如说扬声器离麦克风太近，远端回声把近端语音完全掩盖掉了，那么回声消除的效果肯定是不好的。
>                   这种情形下，可以采取比较激进的策略，把远端回声和近端语音一起干掉，然后适当地填充舒适噪音。
>
>       单讲和双讲判断：
>           在线性自适应滤波做完了以后，可以利用残留回声和麦克风采集到的远端回声信号的相关性来检测是处于单讲还是双讲状态。根据单讲还是双讲状态，可以进一步调整衰减因子
>

- **回音消除模块：**
>       回声消除模块要有能力区分这三种情形，才能针对各种情形采取不同的算法
>       通过VAD可以区分非语音段和语音段
>       回声消除主要包含两个步骤：
>           1、线性自适应滤波
>               线性自适应滤波就是对fe=F(fs)求解，建立远端回声的语音模型，进行第一轮回声消除
>           2、非线性处理，有两个步骤
>               (1)、残留回声处理
>                   残留回声处理进行第二轮回声消除，处理残留回声
>               (2)、非线性剪切处理
>                   非线性剪切处理就是对衰减量达到阈值的语音信号进行比较激进的剪切处理
>
>       线性自适应滤波和非线性剪切处理现状：
>           线性自适应滤波和非线性剪切处理在学术论文和开源项目中能找到东西学习。残留回声处理就很难，一般都是要靠团队自行摸索、积累和创新。正是因为如此，语音技术的门槛才如此的高
>

- **线性自适应滤波器：**
>       实现线性自适应滤波器有两个难点：
>           1、快速收敛
>               在收敛阶段，采集到声音信号要求只有远端的回声信号，不能混有近端的语音信号。近端的语音信号和远端的参考语音信号没有相关性，会对自适应滤波器的收敛过程造成扰乱。
>               因此，我们的策略是让自适应滤波器收敛的时间尽量地短，短到收敛过程的时间段里采集进来的信号只有远端的回声信号，这样自适应滤波器收敛的效果就会很好。
>                   在收敛好之后，滤波器就稳定下来了，就可以用来过滤远端的回声信号了
>           2、动态自适应
>               在收敛好稳定下来以后，自适应滤波器还要随时自动适应回声馈路的变化。自适应滤波器要能够判断回声馈路是否发生变化，并且能够重新学习和对其进行建模，
>                   不断地调整该滤波器的系数，进入一个新的收敛过程，最后快速地逼近新的回声馈路。
>           这两个难点是一对矛盾的特征，要求自适应滤波器一方面要能够快速收敛后保持系数高度稳定，另外一方面要能够随时保持更新状态跟踪回声馈路的变化
>
>       单讲和双讲处理：
>           a、如果处于远端单讲状态，因为近端没有声音信号（没人说话），可以尽量多地抑制回声，让衰减因子尽量地小；
>           b、如果处于双讲状态，因为线性自适应滤波器是在尽量不损伤近端语音音质的前提下消除回声，回声抑制量不会太大，所以衰减因子相对较大
>

- **非线性处理：**
>       有两方面内容，
>           1、残留回声处理
>               通过自适应滤波器来消除回声，并不能百分之一百把回声消除干净，还需要进一步消除残留的回声
>               一般来说，残留回声消除的策略是利用自适应滤波器处理后的残留回声与远端参考语音信号的相关性，进一步消除残留回声。
>                   相关性越大，说明残留回声越多，需要对残留回声进一步消除的程度越大；反之，相关性越小，说明残留回声较少，需要对残留回声进一步消除的程度越小。
>               首先要通过计算残留回声与参考信号的相关矩阵，得到一个反映消除程度的衰减因子；然后将残留回声乘以衰减因子，从而进一步消除残留回声。
>
>               单讲和双讲处理：
>                   a、如果处于远端单讲状态，因为近端没有声音信号（没人说话），可以尽量多地抑制回声，让衰减因子尽量地小；
>                   b、如果处于双讲状态，因为线性自适应滤波器是在尽量不损伤近端语音音质的前提下消除回声，回声抑制量不会太大，所以衰减因子相对较大
>                   消除残留回声的算法难度甚高。在论文或者开源项目中甚少有可参考的东西，各家厂商都是通过私有的算法来实现的，甚至很多厂商都选择不实现。
>
>           2、非线性剪切处理
>               在完成了上述处理以后，其实剩下的回声一般都比较小了，但不排除仍有一些残留的可以感知的小回声。为了进一步消除这些小回声，要根据前面处理得到的衰减量来做进一步的抑制处理
>               在这里要为衰减量设定一个阈值。一般来说，这个衰减量阈值要设定得比较保守（比较高）
>
>
>
>
>
>

- **回声时延估计：**
>       回声延时长短对回声抵消器的性能有比较大的影响(此处不考虑pc上的线程同步的问题)，过长的滤波器抽头也无法实际应用，因此时延估计算法就显得比较重要了。
>       webRTC的回声时延估计，是采用gips首席科学家Bastian的算法，算法思想：
>           略
>
>       32位bit的物理意义是近似地使用功率谱来统计两帧信号的相关性。
>       如果value_best_candidate接近最差延时(预设)，则表明数值不可靠，这时不更新延时数据；如果数据可靠，则进一步使用一阶markvo模型，比照上一次时延数据确定本次最终的更新时延last_delay
>
>       回声消除时间调试：
>           回声消除分为三部分：
>               T0：远端声音经过回音反馈，被mic采集的时间，声音传播时间
>               T1：远端声音传输到近端，被回声消除函数copy一份来做参考声音的时间
>               T2：近端录下的带有回声的声音被送到回声消除函数进行处理的时间
>           其中T1、T2比较大，T0可以忽略
>           如果SDK软件没有编号，只要调试出一个合适的delay time，以后的产品如何改版，回声消除中的delay time就不需要重新调试（不是和网络传输有关？）
>
>
>
>
>
>

- **NLMS（归一化最小均方自适应算法）：**
>       NLMS比传统LMS算法复杂度略高，但收敛速度明显加快。LMS/NLMS性能差于AP和RLS算法
>       webrtc使用了分段块频域自适应滤波(PBFDAF)算法，这也是自适应滤波器的常用算法
>
>
>

- **NLP（非线性滤波）：**
>       webrtc采用了维纳滤波器
>       此处只给出传递函数的表达式，设估计的语音信号的功率谱为Ps(w)，噪声信号的功率谱为Pn(w)，则滤波器的传递函数为H(w)=Ps(w)/(Ps(w)+Pn(w))
>
>
>
>
>

- **CNG（舒适噪声产生）：**
>       舒适噪音生成（comfort noise generator，CNG）是一个在通话过程中出现短暂静音时用来为电话通信产生背景噪声的程序
>       webrtc采用的舒适噪声生成器比较简单，首先生成在[0 ,1]上均匀分布的随机噪声矩阵，再用噪声的功率谱开方后去调制噪声的幅度
>
>
>
>
>
>
>

- **待续：**
>       参考： https://www.infoq.cn/article/how-does-echo-cancellation-technology-work-in-av   音视频社交中回声消除技术是如何实现的
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
