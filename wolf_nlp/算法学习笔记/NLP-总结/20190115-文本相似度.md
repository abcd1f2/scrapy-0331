### nlp-文本相似度
- **概述：**
>       文本相似度有两种：
>           字面距离：
>               编辑距离
>               Jaro距离
>               Simhash
>
>           语义相似度，语义距离：
>               LSA模型
>               PLSA模型
>               LDA模型
>               word2vec模型
>
>
>
>       方法1：最简单的文本相似度计算方法可以利用空间向量模型，计算分词后文本的特征向量的相似性
>           缺点：计算效率问题，无法针对海量文本进行两两相似性判断。
>       方法2：模仿生物学指纹的特点，对每一个文本构造一个指纹，作为文本的标识，指纹一般为固定长度较短的字符串
>           比如md5或者sha哈希值，容易发生雪崩效应，微小差异造成指纹不同。
>           生物学指纹应该有的特点：
>               1、指纹是确定性的，相同的文本指纹相同
>               2、指纹越相似，文本相似度越高
>               3、指纹生成和匹配效率高
>           文本指纹去重算法：
>               k-shingle算法：
>                   设定k窗口大小，然后使用jarccard系数判断文本是否重复，计算量巨大，业界很少采用。
>               [Google的simhash算法](https://github.com/nwaiting/wolf-ai/blob/master/wolf_nlp/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/google%E7%AE%97%E6%B3%95/Simhash-%E6%96%87%E6%9C%AC%E5%8E%BB%E9%87%8D.md)：详情见链接
>               minhash算法：
>                   Minhash也是一种LSH算法，同时也是一种降维的方法。
>                   基本思想：
>                       使用一个随机的hash函数对集合A和集合B中的每个元素hash，hmin(A)、hmin(B)分别表示hash后集合A和集合B的最小值，那么P(hmin(A)==hmin(B))=jaccard(A,B)。
>                       这是minhash算法的核心。其中hmin(A)为哈希函数h(x)对集合A的最小哈希值。
>                   Minhash算法采用最小哈希函数族（一组随机的最小哈希函数）来构建文档的最小哈希签名。
>                   文档的最小哈希签名矩阵是对原始特征矩阵降维的结果。
>                   应用过程中，可以使用k个最小函数分别计算出集合的哈希最小值。设hi表示第i个最小hash函数，最小签名矩阵中列向量为样本si的最小签名向量，其中wij表示第j个最小hash函数对样本i的最小哈希值。
>                   当k小于原始集合的长度(k<<n)时，就相当于对数据降维。
>               top-k最长句子签名算法：
>                   略
>
>

- **内容型网页文本指纹算法：**
>       达观数据在网页型（小说、新闻等）去重任务经验：
>           指纹识别算法是实现指纹识别的关键，它决定了识别率的高低，是指纹识别技术的核心。
>       指纹生成过程：
>           主要将文本全部转换成拼音，截取每个字拼音的首字母、统计该粒度内字母的频率分布，通过和参考系比较，将结果归一化，按字母序，将数字表征转换陈个数字。
>       算法描述：
>           1、转拼音：
>               可以解决字符集编码不一致的问题，可以利用成熟的英文指纹算法，减小分布空间，同时可以解决同音字替换问题
>           2、截取拼音首字母：
>               减小存储长度和分布空间
>           3、提取首字母频率：
>               选择多少字来计算指纹，统计频率分布。需要设置颗粒度的大小（分段大小）以及重叠率。
>       特点：
>           大粒度容错性高，但是匹配率低；小粒度容错性低，但是误报率高且敏感度高
>       重叠率是指设置指纹计算片段移动的窗口大小：
>           假设拼音内容长为2n，颗粒长度为n，重叠率为50%，则需要计算的指纹片段分别为[1,n],[n/2,3n/2],[n,2n]
>       4、减去参考系：
>           频率减去参考系
>       5、归一化：将每个字母的数字表征归一化到一个闭区间去，如[0,9]，按照字母顺序连接数字特征，变成一个数字，即指纹。
>           若空间为[0,9],即一个20位的整数，2^64，需要 8 byte
>           若空间为[0,7],可用一个20位的8进制数，8^20,需要 8 byte
>           若空间为[0,3],只需要 4^20, 共40 bit, 5 byte
>           若空间为[0,1],需要2^20,20 bit,3 byte
>           归一化算法：
>               输入：片段频率集合S:[s1,s2,s3,…sn]
>               参数：指纹集合dnas:[]
>
>               计算基数radix:=pow(2, log(m)/log(2) )
>               FOR 片段频率s IN S
>                   修正频率,每个频率值:=max(频率，基数)
>                   指纹dna:=空串
>                   FOR tmp IN s[m-5:m]
>                       将tmp转换成整数，基数为radix
>                       将tmp转换成字符串，基数为radix
>                       dna:=dna连接tmp
>                       dnas:=dnas添加dna
>               END
>               输出：指纹集合dnas
>
>
>
>

- **达观指纹系统结构：**
>       达观指纹追踪系统：
>           爬虫系统
>           指纹生成系统
>           指纹存储系统（存储层包括匹配结果信息库、网页库以及指纹库）
>           指纹查询和对比
>           指纹分析
>           数据分析
>           后台管理系统
>
>
>
>
>

- **使用simhash进行相似度计算：**
>       https://github.com/leonsim/simhash  开源simhash库
>       Simhash的一种典型实现就是将一个文档最后转换成一个64位的字节的特征值或者simhash值。最后只需要判断特征值的距离是不是小于3，就可以判断两个文档是否相似。
>       可以使用海明距离，即两个simhash值取异或后二进制中1的个数。
>       计算6位simhash值典型的实现算法：
>           1、将Doc分词和计算权重，抽取出n个(关键词，权重)对，即(feature,weight)
>           2、计算关键词的hash，生成(hash,weight)，并将hash和weight相乘，这一过程是对hash值加权
>           3、将hash和weight相乘的值相加，比如[13, 108, -22, -5, -32, 55]，转换成最终的110001，规则为正数为1负数为0
>
>       参考：
>           https://yanyiwu.com/work/2014/01/30/simhash-shi-xian-xiang-jie.html
>           https://github.com/duoergun0729/nlp/blob/master/%E6%96%87%E6%A1%A3%E7%9B%B8%E4%BC%BC%E5%BA%A6.md
>
>
>
>

- **参考：**
>       http://www.datagrand.com/blog/fingerprint.html  [网站文章如何能自动判定是抄袭？一种算法和实践架构剖析]
>       https://www.cnblogs.com/xlturing/p/6136690.html     NLP点滴——文本相似度
>
>
>
>
>
>
>
>
>
>
>
>
