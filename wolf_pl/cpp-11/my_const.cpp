#include <iostream>


/*
    常引用：
        既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就应使用常引用
        常引用声明方式：
            const 类型标识符 &引用名=目标变量名
    临时对象都是const类型的。因此上面的表达式就是试图将一个const类型的对象转换为非const类型，这是非法的。引用型参数应该在能被定义为const的情况下，尽量定义为const

    “引用”作为函数返回值：
        类型标识符 &函数名（形参列表及类型说明）{ //函数体 }
        好处：
            在内存中不产生被返回值的副本；（注意：正是因为这点原因，所以返回一个局部变量的引用是不可取的。因为随着该局部变量生存期的结束，相应的引用也会失效，产生runtime error!
        1、不能返回局部变量的引用
        2、不能返回函数内部new分配的内存的引用
            被函数返回的引用只是作为一个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak
        3、可以返回类成员的引用，但最好是const
        4、流操作符重载返回值申明为“引用”的作用
        5、在另外的一些操作符中，却千万不能返回引用：+ - * / 四则运算符

    结构和联合区别：
        1、结构和联合都是由多个不同的数据类型成员组成, 但在任何同一时刻, 联合中只存放了一个被选中的成员（所有成员共用一块地址空间）, 而结构的所有成员都存在（不同成员的存放地址不同）
        2、对于联合的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了, 而对于结构的不同成员赋值是互不影响的
        验证大端和小端：
        union U{
            short a;
            char c;
        };
        U u;
        u.a=0x1234; //只要我们取出变量c的值，进行比对；若其值为34h（低字节保存在低地址中），则机器为小端模式（数据的高字节保存在内存的高地址中），若其值为12h，则机器为大端模式。

    哪几种情况只能用intialization list 而不能用assignment?
        当类中含有const、reference 成员变量；基类的构造函数都需要初始化表

    C++是不是类型安全的？
        不是。两个不同类型的指针之间可以强制转换（用reinterpret cast)。C#是类型安全的。

    main 函数执行以前，还会执行什么代码？
        全局对象的构造函数会在main 函数之前执行，atexit函数在main函数返回之后
        操作系统装载程序之后，首先运行的代码并不是main的第一行，而是某些特别的代码，这些代码准备好main函数执行所需要的环境，并且负责调用main函数，这时候你才可以再main函数里放心大胆的写各种代码：申请内存、使用系统调用、触发异常、访问IO。
        在main函数返回之后，他会记录main函数的返回值，调用atexit注册的函数，然后结束进程。

    描述内存分配方式以及它们的区别?
        1、从静态存储区域分配
            内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static 变量
        2、在栈上创建
        3、从堆上分配

    const与#define 相比，有何优点？
        const作用：
            const作用：定义常量、修饰函数参数、修饰函数返回值三个作用。
            被Const修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。
        const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误

    数组与指针的区别？
        1、数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。指针可以随时指向任意类型的内存块。
        2、用运算符sizeof 可以计算出数组的容量（字节数）。sizeof(p),p 为指针得到的是一个指针变量的字节数，而不是p 所指的内存容量。
            C++/C 语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。

    栈内存与文字常量区?
            char str1[] = "abc";
        　　char str2[] = "abc";
            //str1 != str2

        　　const char str3[] = "abc";
        　　const char str4[] = "abc";
            // str3 != str4

        　　const char *str5 = "abc";
        　　const char *str6 = "abc";
            // str5 == str6

        　　char *str7 = "abc";
        　　char *str8 = "abc";
            // str7 == str8
        str1,str2,str3,str4是数组变量，它们有各自的内存空间；而str5,str6,str7,str8是指针，它们指向相同的常量区域

    将程序跳转到指定内存地址？
        要对绝对地址0x100000赋值，我们可以用(unsigned int*)0x100000 = 1234;那么要是想让程序跳转到绝对地址是0x100000去执行，应该怎么做？
        首先要将0x100000强制转换成函数指针,然后再调用它
            typedef void(*)() voidFuncPtr;
            *((voidFuncPtr)0x100000)();

    int id[sizeof(unsigned long)];这个对吗？
        正确 这个 sizeof是编译时运算符，编译时就确定了  ,可以看成和机器有关的常量

    引用与指针有什么区别？
        1) 引用必须被初始化，指针不必。
        2) 引用初始化以后不能被改变，指针可以改变所指的对象。
        3) 不存在指向空值的引用，但是存在指向空值的指针。

    全局变量和局部变量有什么区别？是怎么实现的？操作系统和编译器是怎么知道的？
        使用方式不同：通过声明后全局变量程序的各个部分都可以用到；局部变量只能在局部使用；分配在栈区。
        操作系统和编译器通过内存分配的位置来知道的，全局变量分配在全局数据段并且在程序开始运行的时候被加载。局部变量则分配在堆栈里面 。

    如何判断一段程序是由C 编译程序还是由C++编译程序编译的？
        #ifdef __cplusplus
            cout<<“c++";
        #endif

    C++写个程序，如何判断一个操作系统是16位还是32位的？
        定义一个指针p，打印出sizeof(p),如果节后是4，则表示该操作系统是32位，打印结果是2，表示是16位。
        1、利用sizeof
            可以使用sizeof计算int的字节长度来判断是32位还是16位。
            32位机器下：sizeof(int) = 4；16位机器下：sizeof(int) = 2
            但是实际中可能64位的机器sizeof(int)也是4字节，因为很多时候是编译器决定要占用几个字节
        2、利用最大值
            机器位数不同则表示的数字的最大值是不同的。
            32位机器下int的最大值为2147483647，16位机器下int的最大值是32767
            我们可以利用最大值是否溢出情况来判断
                定义一个变量num赋值32768，如果是16位机器这个时候超过了int最大值变成了-32768，如果是32位机器不会超过
        3、对0取反
            32位机器下无符号整型的数值范围是[0，4294967295]，16位机器下无符号整型的范围是[0，65535]
            0的二进制是所有位都是0
                32位下对0取反的结果是所有位都是1，如果把这个数赋值给一个无符号整型变量num，则num值为4294967295
                16位下对0取反的结果是所有位都是1，如果把这个数赋值给一个无符号整型变量num，则num值为65535
            利用对0取反后的结果赋值给无符号整型变量来判断值是否大于65535即可

    多态类中的虚函数表是 Compile-Time，还是 Run-Time 时建立的？
        虚拟函数表是在编译期就建立了,各个虚拟函数这时被组织成了一个虚拟函数的入口地址的数组。
        而对象的隐藏成员--虚拟函数表指针是在运行期--也就是构造函数被调用时进行初始化的,这是实现多态的关键。

    float a,b,c , 问等式 (a+b)+c==(b+a)+c 和 (a+b)+c==(a+c)+b 能否成立？
        两者都不行。在比较float或double时，不能简单地比较。

    重复多次 fclose 一个打开过一次的 FILE *fp 指针会有什么结果？
        导致文件描述符结构中指针指向的内存被重复释放，进而导致一些不可预期的异常

    是不是一个父类写了一个virtual 函数，如果子类覆盖它的函数不加virtual ,也能实现多态?
        virtual修饰符会被隐形继承的。virtual可加可不加。子类的空间里有父类的所有变量(static除外)。
        子类覆盖它的函数不加virtual ,也能实现多态。在子类的空间里，有父类的私有变量。私有变量不能直接访问。

    多态的作用？
        1、隐藏实现细节，使得代码能够模块化；扩展代码模块，实现代码重用；
        2、接口重用：为了类在继承和派生的时候，保证使用家族中任一类的实例的某一属性时的正确调用

    当一个类A 中没有声命任何成员变量与成员函数,这时sizeof(A)的值是多少？
        sizeof(A) = 1；
        编译器不允许一个类的大小为0，会为它分配1字节的内存。试想，若，不这样做，那2个类A的实例在内存中将会无法区分
        一个空类对象的大小是1byte。这是被编译器安插进去的一个字节，这样就使得这个空类的两个实例得以在内存中配置独一无二的地址

     C++里面是不是所有的动作都是main()引起的？
        比如全局变量的初始化，就不是由 main 函数引起的。

    内联函数在编译时是否做参数类型检查？
        内联函数要做参数类型检查，这是内联函数跟宏相比的优势。

    在 C++的一个类中声明一个 static 成员变量有没有用？
        在C++类的成员变量被声明为 static（称为静态成员变量），意味着它为该类的所有实例所共享，也就是说当某个类的实例修改了该静态成员变量，也就是说不管创建多少对象，static修饰的变量只占有一块内存。
        其修改值为该类的其它所有实例所见；而类的静态成员函数也只能访问静态成员（变量或函数）。static是加了访问控制的全局变量，不被继承。

    函数模板与类模板有什么区别？
        函数模板的实例化是由编译程序在处理函数调用时自动完成的
        而类模板的实例化必须由程序员在程序中显式地指定

    函数重载，我们靠什么来区分调用的那个函数？靠返回值判断可以不可以？
        问题是在 C++/C 程序中，我们可以忽略函数的返回值。在这种情况下，编译器和程序员都不知道哪个 Function 函数被调用。

    所有的运算符都能重载吗？
        不能被重载的运算符
        1、不能改变 C++内部数据类型（如 int,float 等）的运算符
        2、不能重载‘.’，因为‘.’在类中对任何成员都有意义，已经成为标准用法

    基类的析构函数不是虚函数，会带来什么问题？
        派生类的析构函数用不上，会造成资源的泄漏

    There are two int variables: a and b, don't use“if”, “? :”, “switch”or other judgement statements, find out the biggest one of the two numbers？
        ( ( a + b ) + abs( a - b ) ) / 2

    在不用第三方参数的情况下，交换两个参数的值。
        a = a + b;
        b = a – b;
        a = a – b;

    写一个能做左值的函数(方法有很多)
        max(x, y) += 2874 + 55;
        int &max(int & x, int & y) {
                return x > y? x : y;
            }

    三元表达式“？:”问号后面的两个操作数必须为同一类型
        cout << (true?1:"1") << endl;   //错误

    数组长度定义：
        而数组定义要求长度必须为编译期常量

    默认构造函数调用带参构造函数可以吗？
        不能。在默认构造函数内部再调用带参的构造函数属用户行为而非编译器行为，亦即仅执行函数调用，而不会执行其后的初始化表达式。
        只有在生成对象时，初始化表达式才会随相应的构造函数一起调用。

    一个栈的入栈序列为ABCDEF，则不可能的出栈序列是：
        该题主要是考虑栈的核心思想是先进后出，并且需要注意入栈和出栈的顺序是未知的，例如你可以先入栈ABCD，然后出栈D，然后入栈E，出栈E，入栈F，出栈F，然后CBA依次出栈，也就是DEFCBA的情况。
        任何出栈的元素后面出栈的元素必须满足以下三点：
            1、在原序列中相对位置比它小的，必须是逆序；
            2、在原序列中相对位置比它大的，顺序没有要求；
            3、以上两点可以间插进行。

    写出判断ABCD四个表达式的是否正确：
        int a = 4;
        (a++) += a; //错误
        左侧不是一个有效变量，不能赋值，可改为 (++a) += a;

    return语句效率：
        1、return String(s1 + s2);
        2、String temp(s1 + s2); return temp;
        解释：
            1、这是临时对象的语法，表示“创建一个临时对象并返回它”
            2、首先，temp 对象被创建，
                同时完成初始化；
                然后拷贝构造函数把 temp 拷贝到保存返回值的外部存储单元中；
                最后，temp 在函数结束时被销毁（调用析构函数）
            然而“创建一个临时对象并返回它”的过程是不同的，编译器直接把临时对象创建并初始化在外部存储单元中，省去了拷贝和析构的化费，提高了效率。

    int max( int *ia, int sz ); 和 int max( int *, int b= 10 ); 算函数重载？还是重复声明？
        如果在两个函数的参数表中只有缺省实参不同则第二个声明被视为第一个的重复声明 。










*/


int main(int argc, char const *argv[]) {
    /* code */
    return 0;
}
