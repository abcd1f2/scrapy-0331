## linux - 进程内存模型
- **概述：**
>       linux虚拟内存管理的几个概念：
>           1、每个进程都有独立的虚拟地址空间，进程访问的虚拟地址并不是真正的物理地址； 
>           2、虚拟地址可通过每个进程上的页表(在每个进程的内核虚拟地址空间)与物理地址进行映射，获得真正物理地址； 
>           3、如果虚拟地址对应物理地址不在物理内存中，则产生缺页中断，真正分配物理地址，同时更新进程的页表；
>               如果此时物理内存已耗尽，则根据内存替换算法淘汰部分页面至物理磁盘中
>
>
>

- **linux虚拟地址空间分布：**
>       Linux 使用虚拟地址空间，大大增加了进程的寻址空间，由低地址到高地址分别为：
>           1、只读段：
>               该部分空间只能读，不可写；(包括：代码段、rodata 段(C常量字符串和#define定义的常量) )
>           2、数据段：
>               保存全局变量、静态变量的空间
>           3、堆：
>               就是平时所说的动态内存， malloc/new 大部分都来源于此。其中堆顶的位置可通过函数 brk 和 sbrk 进行动态调整
>               brk/sbrk 函数控制堆顶 _edata(_edata指针,glibc里面定义,指向数据段的最高地址)往高地址方向变化
>           4、文件映射区域：
>               如动态库、共享内存等映射物理空间的内存，一般是 mmap 函数所分配的虚拟地址空间
>           5、栈：
>               用于维护函数调用的上下文空间，一般为 8M ，可通过 ulimit –s 查看
>               %esp 执行栈顶，往低地址方向变化
>           6、内核虚拟空间：
>               用户代码不可见的内存区域，由内核管理(页表就存放在内核虚拟空间)
>

- **内存分配原理：**
>       从操作系统角度来看，进程分配内存有两种方式，分别由两个系统调用完成：
>           1、brk
>               将数据段(.data)的最高地址指针_edata(_edata指针,glibc里面定义,指向数据段的最高地址)往高地址推
>               进程调用A=malloc(30K)，malloc函数会调用brk系统调用，将_edata指针往高地址推30K，就完成虚拟内存分配，A这块内存现在还是没有物理页与之对应的，
>                   等到进程第一次读写A这块内存的时候，发生缺页中断，这个时候，内核才分配A这块内存对应的物理页。
>                   也就是说，如果用malloc分配了A这块内容，然后从来不访问它，那么，A对应的物理页是不会被分配的。
>           2、mmap
>               mmap内存映射文件是在堆和栈的中间（例如libc-2.2.93.so，其它数据文件等）
>               malloc大于128k的内存，使用mmap分配内存，在堆和栈之间找一块空闲内存分配(对应独立内存，而且初始化为0)
>               mmap是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存
>           两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，
>               然后建立虚拟内存和物理内存之间的映射关系
>       在标准C库中，提供了malloc/free函数分配释放内存，这两个函数底层是由brk，mmap，munmap(释放)这些系统调用实现的
>
>
>       内存分配流程：
>           malloc大于128k的内存，使用mmap分配内存，在堆和栈之间找一块空闲内存分配(对应独立内存，而且初始化为0)
>
>       为什么有brk和mmap分配内存方式：
>           1、brk分配的内存需要等到高地址内存释放以后才能释放，而mmap分配的内存可以单独释放
>               当最高地址空间的空闲内存超过128K（可由M_TRIM_THRESHOLD选项调节）时，执行内存紧缩操作（trim）
>               同时堆是一个连续空间，并且堆内碎片由于没有归还 OS ，如果可重用碎片，再次访问该内存很可能不需产生任何系统调用和缺页中断，这将大大降低 CPU 的消耗
>               可通过 mallopt(M_MMAP_THRESHOLD, <SIZE>) 来修改这个临界值
>           2、如果使用 mmap 分配小内存，会导致地址空间的分片更多，内核的管理负担更大
>

- **linux进程载入**
>       在linux系统中，程序被载入内存时，内核为用户进程地址空间建立了代码段、数据段和堆栈段。
>       在数据段和堆栈段之间的空闲区域用于动态内存分配
>
>


- **c语言分配内存的几种方式：**
>       常见的几种内存分配：
>           1、malloc分配的内存是位于堆中的,并且没有初始化内存的内容,因此基本上malloc之后,调用函数memset来初始化这部分的内存空间.
>           2、calloc则将初始化这部分的内存,设置为0.
>           3、而realloc则对malloc申请的内存进行大小的调整.申请的内存最终需要通过函数free来释放.
>           4、而sbrk则是增加数据段的大小
>
>       malloc：
>           C函数库内部通过一定的结构来保存当前有多少可用内存。如果程序 malloc的大小超出了库里所留存的空间,那么将首先调用brk系统调用来增加可用空间,然后再分配空间。
>               free时,释放的内存并不立即返回给os, 而是保留在内部结构中
>           brk类似于批发,一次性的向OS申请大的内存,而malloc等函数则类似于零售,满足程序运行时的要求.这套机制类似于缓冲
>
>       mmap：
>           系统调用实现了动态内存分配功能，可以将一个磁盘文件的全部或部分内容映射到用户空间中，进程读写文件的操作变成了一个读写内存的操作。
>            linux/mm/mmap.c文件的do_mmap_pgoff()函数，是mmap系统调用实现的核心。
>           do_mmap_pgoff的函数中，只是新建了一个vm_area_struct结构，并把file结构的参数赋值给其成员变量m_file，并没有把文件内容实际装入内存。
>

- **查看进程缺页中断信息：**
>       命令：
>           ps -o majflt,minflt -C <program_name>
>        或 ps -o majflt,minflt -p <pid>
>           majflt 代表 major fault ，指大错误
>           minflt 代表 minor fault ，指小错误
>           这两个数值表示一个进程自启动以来所发生的缺页中断的次数
>           majflt 与 minflt 的区别：
>               majflt 表示需要读写磁盘，可能是内存对应页面在磁盘中需要load 到物理内存中，也可能是此时物理内存不足，需要淘汰部分物理页面至磁盘中
>

- **待续：**
>       参考：https://blog.csdn.net/gfgdsg/article/details/42709943    Linux内存分配小结--malloc、brk、mmap
>           https://blog.csdn.net/zhangzhebjut/article/details/39060253     Linux - 进程(一) 进程空间
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
