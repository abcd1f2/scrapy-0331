## linux - TCP网络
- **概述：**
>       tcp/udp一般采用五元组来定位一个连接
>       监听端口和用来发送数据的端口是同一个端口
>
>
>
>
>
>

- **tcp连接状态：**
>       tcp的状态分为三个阶段：
>           一、建立连接阶段
>               三次握手过程，从connect主动发起连接开始，
>                   1、client发送一个syn(seq=x)，进入syn_sent状态，
>                   2、server发送一个syn(seq=y)+(ack=x+1)，进入syn_rcvd状态，
>                   3、client发送一个ack=y+1，进入established状态，server收到ack进入established状态
>           二、数据传输阶段
>               write：一端发送一个(seq=x+1)+(ack=y+1)
>               read：另一端发送一个ack=x+2
>           三、连接断开阶段
>               四次握手，从close开始，
>                   1、一端调用close，发送一个FIN(seq=x+2)+ACK(y+1)，进入FIN_WAIT_1状态
>                   2、另一端收到FIN，进入**CLOSE_WAIT**状态，回一个ACK(x+3)，然后发送一个FIN(seq=y+1)，进入到LAST_ACK状态
>                   3、一端接收到ACK回应进入FIN_WAIT_2状态，接收到FIN进入到**TIME_WAIT**状态，然后发送一个ACK(y+2)回应，状态变为**CLOSED**
>                   4、另一端接收到ACK，状态变为**CLOSED**
>

- **建立连接过程的异常分析：**
>       connect在阻塞和非阻塞模式下的异常：
>           异常一：
>               不插网线，client获取不到ip地址，connect立即返回
>           异常二：
>               网线正常，连接网络失败，能够获取到ip地址，但是ping不通，connect会阻塞，客户端发送的syn得不到相应，
>                   connect会阻塞不返回，具体的超时时间与系统相关，有的可能设置为75秒，有的可能设置为120秒等等，这种不确定的时间等待是应用程序不愿处理的。
>           如何对异常二超时时间可控？
>               方案1：
>                   直接修改系统配置，connect超时时间与/proc/sys/net/ipv4/tcp_syn_retries的值有关，直接修改系统配置可能会影响到其他服务，不易采用
>               方案2：
>                   建立socket
>                   把socket设置为非阻塞模式
>                   调用connect
>                   使用select检查该socket描述符是否可写（注意，是可写）
>                   根据select返回结果判断connect结果
>                   将socket恢复为阻塞模式
>               方案3：
>                   connect的实现用到的超时参数是sndtimeo，在net/ipv4/af_inet.c文件中，
>                   在Linux平台下，可以通过在connect之前设置SO_SNDTIMO来达到控制连接超时的目的
>                   struct timeval timeo = {3, 0};
>                   setsockopt(fd, SOL_SOCKET, SO_SNDTIMEO, &timeo, len);
>               参考：https://blog.csdn.net/wy5761/article/details/17695349       connect超时设置
>
>
>       异常1：
>           server端口还未监听，client发送connect，会发生什么？
>           解析：
>               这符合触发发送RST分节的条件，目的为某端口的SYN分节到达，而端口没有监听，那么内核会立即响应一个RST，表示出错。
>                   客户端TCP收到这个RST之后则放弃这次连接的建立，并且返回给应用程序一个错误。正如上面所说的，建立连接的过程对应用程序来说是不可见的，
>                   这是操作系统帮我们来完成的，所以即使进程没有启动，也可以响应客户端。
>       异常2：
>           尝试与一个不存在的server上面某端口建立连接，会发生什么？
>           解析：
>               这次主机已经处于未启动状态，操作系统也帮不上忙了，那么也就是连RST也不能响应给客户端，此时服务器端是一种完全没有响应的状态。那么此时客户端的TCP会怎么办呢？
>               如果客户端TCP没有得到任何响应，那么等待6s之后再发一个SYN，若无响应则等待24s再发一个，若总共等待了75s后仍未收到响应就会返回ETIMEDOUT错误。
>                   这是TCP建立连接自己的一个保护机制，但是我们要等待75s才能知道这个连接无法建立，对于我们所有服务来说都太长了。
>                   更好的做法是在代码中给connect设置一个超时时间，使它变成我们可控的，让等待时间在毫秒级还是可以接收的。
>
>       异常3：
>           Server进程被阻塞，会发生什么？
>               由于某些情况，服务器端进程无法响应任何请求，比如所在主机的硬盘满了，导致进程处于完全阻塞，通常可以用gdb模拟这种情况。
>           解析：
>               建立连接的过程对应用程序是不可见的，那么，这时连接可以正常建立。当然，客户端进程也可以通过这个连接给服务器端发送请求，服务器端TCP会应答ACK表示已经收到这个分节
>                   （这里的收到指的是数据已经在内核的缓冲区里准备好，由于进程被阻塞，无法将数据从内核的缓冲区复制到应用程序的缓冲区），但永远不会返回结果
>
>       异常4：
>           kill server，会发生什么？
>               如：当一个模块上线时，OP同学总是会先把旧的进程杀死，然后再启动新的进程。那么在这个过程中TCP连接发生了什么呢？
>           解析：
>               在进程正常退出时会自动调用close函数来关闭它所打开的文件描述符，这相当于服务器端来主动关闭连接——会发送一个FIN分节给客户端TCP；客户端要做的就是配合对端关闭连接，TCP会自动响应一个ACK，然后再由客户端应用程序调用close函数，也就是我们上面所描述的关闭连接的4次挥手过程。接下来，客户端还需要定时去重连，以便当服务器端进程重新启动好时客户端能够继续与之通信。
>
>                当然，我们要保证客户端随时都可以响应服务器端的断开连接请求，就必须不能让客户端进程再任何时刻阻塞在任何其他的输入上面。比如，书上给的例子是客户端进程会阻塞在标准输入上面，这时如果服务器端主动断开连接，显然客户端不能立刻响应，因为它还在识图从标准输入读一段文本……当然这在实际中很少遇到，如果有多输入源这种情况的话开通通常会用类似select功能的函数来处理，可以同时监控多个输入源是否准备就绪，可以避免上述所说的不能立即响应对端关闭连接的情况。
>
>       异常5：
>           Server进程所在的主机关机，会发生什么？
>           解析：
>               实际上这种情况不会带来什么更坏的后果。在系统关闭时，init进程会给所有进程发送SIGTERM信号，等待一段时间（5~20秒），然后再给所有仍在运行的进程发送SIGKILL信号。
>                   当服务器进程死掉时，会关闭所有文件描述符。带来的影响和上面kill server相同
>
>       异常6：
>           Server进程所在的主机宕机，会发生什么？
>           解析：
>               这是我们线上另一种比较常见的状况。即使宕机是一个小概率事件，线上几千台服务器动不动一两台挂掉也是常有的事。主机崩溃不会像关机那样会预先杀死上面的进程，而是突然性的。那么此时我们的客户端准备给服务器端发送一个请求，它由write写入内核，由TCP作为一个分节发出，随后客户阻塞于read的调用（等待接收结果）。对端TCP显然不会响应这个分节，因为主机已经挂掉，于是客户端TCP持续重传分节，试图从服务器上接收一个ACK，然而服务器始终不能应答，重传数次之后，大约4~10分钟才停止，之后返回一个ETIMEDOUT错误
>
>               这样尽管最后还是知道对方不可达，但是很多时候我们希望比等待4~10分钟更快的知道这个结果。可以为read设置一个超时时间，就得到了一个较好的解决方法。但是这样还是需要等待一个超时时间，事实上TCP为我们提供了更好的方法，用SO_KEEPALIVE的套接字选项——相当于心跳包，每隔一段时间给对方发送一个心跳包，当对方没有响应时会一更短的时间间隔发送，一段时间后仍然无响应的话就断开这个连接
>           1、设置read的超时时间
>           2、设置tcp心跳包
>
>       异常7：
>           服务器进程所在的主机宕机后重启，会发生什么？
>           解析：
>               在客户端发出请求前，服务器端主机经历了宕机——重启的过程。当客户端TCP把分节发送到服务器端所在的主机，服务器端所在主机的TCP丢失了崩溃前所有连接信息，
>                   即TCP收到了一个根本不存在连接上的分节，所以会响应一个RST分节。如果开发的代码足够健壮的话会试图重新建立连接，或者把这个请求转发给其他服务器
>

- **TCP的关闭分析：**
>       当一端收到一个FIN，内核让read返回0来通知应用层另一端已经终止了向本端的数据传送；发送FIN通常是应用层对socket进行关闭的结果
>       tcp的2MSL问题，如下图，
> ![avatar](https://github.com/nwaiting/wolf-ai/blob/master/wolf_others/pl_pic/linux_net_tcp_close_status.png)
>       解析：
>           因为虽然双方都同意关闭连接了，而且握手的4个报文也都协调和发送完毕，按理可以直接回到 CLOSED 状态（就好比从 SYN_SEND 状态到 ESTABLISH 状态那样）；
>               但是因为必须要假想网络是不可靠的，无法保证最后发送的 ACK 报文会一定被对方收到，因此对方处于 LAST_ACK 状态下的SOCKET可能会因为超时未收到 ACK 报文，
>               而重发 FIN 报文，所以这个 TIME_WAIT 状态的作用就是用来重发可能丢失的 ACK 报文
>
>

- **数据传输阶段分析：**
>       数据传输过程中，有一些数据传输的策略，
>           1、超时重传
>               超时重传机制用来保证TCP传输的可靠性。每次发送数据包时，发送的数据报都有seq号，接收端收到数据后，会回复ack进行确认，表示某一seq号数据已经收到。
>                   发送方在发送了某个seq包后，等待一段时间，如果没有收到对应的ack回复，就会认为报文丢失，会重传这个数据包
>           2、快速重传
>               接受数据一方发现有数据包丢掉了。就会发送ack报文告诉发送端重传丢失的报文。如果发送端连续收到标号相同的ack包，则会触发客户端的快速重传。
>                   比较超时重传和快速重传，可以发现超时重传是发送端在傻等超时，然后触发重传；而快速重传则是接收端主动告诉发送端数据没收到，然后触发发送端重传
>           3、流量控制
>               这里主要说TCP滑动窗流量控制。TCP头里有一个字段叫Window，又叫Advertised-Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。
>                   于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。 滑动窗可以是提高TCP传输效率的一种机制。
>           4、拥塞控制
>               滑动窗用来做流量控制。流量控制只关注发送端和接受端自身的状况，而没有考虑整个网络的通信情况。拥塞控制，则是基于整个网络来考虑的。考虑一下这样的场景：某一时刻网络上的延时突然增加，那么，TCP对这个事做出的应对只有重传数据，但是，重传会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，于是，这个情况就会进入恶性循环被不断地放大。试想一下，如果一个网络内有成千上万的TCP连接都这么行事，那么马上就会形成“网络风暴”，TCP这个协议就会拖垮整个网络。为此，TCP引入了拥塞控制策略。拥塞策略算法主要包括：慢启动，拥塞避免，拥塞发生，快速恢复
>
>
>
>

- **为什么建立连接是3次，关闭需要4次？**
>       解析：
>           因为服务端的 LISTEN 状态下的 SOCKET 当收到 SYN 报文的建连请求后，它可以把 ACK 和 SYN（ACK 起应答作用，而 SYN 起同步作用）放在一个报文里来发送。但关闭连接时，当收到对方的 FIN 报文通知时，它仅仅表示对方没有数据发送给你了，但是你还可以给对方发送数据，也有这么种可能，你还有一些数据在传给对方的途中，所以你不能立马关闭连接,也即你可能还需要把在传输途中的数据给对方之后，又或者，你还有一些数据需要传输给对方后，（再关闭连接）再发送FIN 报文给对方来表示你同意现在可以关闭连接了，所以它这里的 ACK 报文和 FIN 报文多数情况下都是分开发送的。
>
>       断开连接过程：
>           1）客户端 A 发送一个 FIN，用来关闭客户 A 到服务器 B 的数据传送；
>           2）服务器 B 收到这个 FIN，它发回一个 ACK，确认序号为收到的序号加 1。和 SYN 一样，一个 FIN 将占用一个序号；
>           3）服务器 B 关闭与客户端 A 的连接，发送一个 FIN 给客户端 A；
>           4）客户端 A 发回 ACK 报文确认，并将确认序号设置为收到序号加 1。
>
>
>

- **待续：**
>       https://blog.csdn.net/yusiguyuan/article/details/21439719   再次深入理解TCP网络编程中的send和recv
>       https://blog.csdn.net/q1007729991/column/info/15153/2       Linux 网络编程修炼指南-内功心法(116篇文章)
>       https://blog.csdn.net/hguisu/article/details/38700899   TCP连接的状态详解以及故障排查
>       https://blog.csdn.net/q1007729991/article/details/69091877  0-Linux 网络编程修炼指南——内功心法
>
>
>
>
>
>
>
>
>
>
