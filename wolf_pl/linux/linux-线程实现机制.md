## linux - 线程实现机制
- **概述：**
>       只要是共享的资源，那么它就可以看作临界资源，而临界资源的访问需要同步。
>
>
>
>
>
>
>

- **线程共享和独享资源：**
>       共享：
>           地址空间
>           全局变量
>           打开的文件
>           子进程
>           闹钟
>           信号及信号服务程序
>           记账信息
>       独占资源：
>           程序计数器
>           寄存器
>           栈
>           状态字
>
>

- **线程模型：**
>       内核态线程数量极少，用户态线程数量较多。
>       每个内核态线程可以服务一个或多个用户态线程，用户态线程会被多路复用到内核态线程上。
>

- **锁原理：**
>       硬件层面：CPU提供了原子操作、关中断、锁内存总线的机制
>       操作系统：OS基于这几个CPU硬件机制，能够实现锁
>       用户空间：基于锁，实现各种同步机制（信号量、消息、Barrier等）
>
>       所有的同步操作最基础的理论就是原子操作。内存屏障、锁都是为了保证在不同平台或者是CPU类型下的原子操作。
>       原子操作在单核、单线程、无中断，且编译器不优化的情况下是确定的，是按照代码顺序执行的，所以不存在异步的问题。
>

- **锁实现：**
>       见下图：
>![avatar](https://github.com/nwaiting/wolf-ai/blob/master/wolf_others/pic/linux_lock.jpg)
>
>
>

- **如何避免死锁：**
>       使用互斥锁，应当尽量避免同时获得多个锁，且遵循以下原则：
>           1、线程在需要多个锁时，都按相同的先后顺序获得锁
>           2、尽量使用pthread_mutex_trylock替代pthread_mutex_lock调用
>           3、为了解决死锁的问题，需要引入更多的线程互斥与同步机制，如条件变量等
>
>



- **参考：**
>       https://www.ibm.com/developerworks/cn/linux/kernel/l-thread/index.html  Linux 线程实现机制分析
>       https://cn.aliyun.com/jiaocheng/128492.html
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
