## python - re  正则表达式
- **概述：**
>
>

- **re所定义的flag：**
>       re.I    忽略大小写
>       re.L    字符集本地化，表示特殊字符集\w, \W, \b, \B, \s, \S 依赖于当前环境
>               这个功能是为了支持多语言版本的字符集，如转义符\w，在英文环境，表示[a-zA-Z0-9_]，即所有的英文字符和数字，
>               但是如果在法语环境的话，默认模式下不能匹配"é"或"ç"字符，加上L就可以匹配，但是任然不能匹配中文字符。
>       re.M    多行模式
>               改变了^和$的行为
>               如：s = '''first line
>                       second line
>                       third line'''
>                   re.compile("^\w+")  结果为：['first']
>                   re.compile("^\w+", re.M)    结果为['first', 'second', 'third']
>                   re.compile("\w+$")  结果为：['line']
>                   re.compile("\w+$", re.M)    结果为：['line', 'line', 'line']
>       re.S    即为"."并且包括换行符在内的任意字符("."不包括换行符)
>               如（继续使用上面的s字符串）
>                   re.compile(".+")    结果为：['first line', 'second line', 'third line']
>                   re.compile(".+", re.S)  结果为：['first line\nsecond line\nthird line']
>       re.U    表示特殊字符集\w, \W, \b, \B, \d, \D, \s, \S 依赖于 Unicode 字符属性数据库
>       re.X    VERBOSE冗余模式，此模式会忽略正则表达式中的空白和#号注释的内容
>               如写一个匹配邮箱的正则表达式：
>                   re.compile("[\w+\.]+@[a-zA-Z\d]+\.(com|cn)")
>                或：re.compile("""[\w+\.]+  # 匹配@符前的部分
>                               @  # @符
>                               [a-zA-Z\d]+  # 邮箱类别
>                               \.(com|cn)   # 邮箱后缀  """, re.X)
>

- **元字符列表：**
>       . ^ $ * + ? {} [] \ | ()
>       .   匹配除了换行符外的任何字符，在alternate模式(re.DOTALL)下它甚至可以匹配换行符。.通常被用于想匹配任何字符的地方
>       ^   匹配开始位置，多行模式下匹配每一行的开始
>       $   匹配结束位置，多行模式下匹配每一行的结束
>       *   {0,}
>       +   {1,}
>       ?   {0,1}
>       {m,n}   m到n次
>       \\      转义字符，因为只使用单\的话，那么可能还是特殊字符，如：\\.只能匹配.不能再匹配任意字符。下同
>       \   表示特殊格式或允许使用特殊字符而不调用它的特殊用法。为了防止不必要的转义，使用Python的raw字符串表示，即在字符串前加上"r"就不会被特殊处理，如r"\n"就是包含"\"和"n"两个字符
>       |       逻辑表达式或，比如 a|b 代表可匹配 a 或者 b
>
>       (...)   捕获分组
>       (?iLmsux)   分组中可以设置模式，iLmsux之中的每个字符代表一个模式,用法参见 **re所定义的flag**
>       (?:...)     分组的不捕获模式，计算索引时会跳过这个分组
>       (?P<name>...)   分组的命名模式，取此分组中的内容时可以使用索引也可以使用name
>       (?P=name)   分组的引用模式，可在同一个正则表达式用引用前面命名过的正则
>       (?#...)     注释，不影响正则表达式其它部分,用法参见**re所定义的flag**
>       (?=...)     顺序肯定环视，表示所在位置右侧能够匹配括号内正则
>       (?!...)     顺序否定环视，表示所在位置右侧不能匹配括号内正则
>       (?<=...)    逆序肯定环视，表示所在位置左侧能够匹配括号内正则
>       (?<!...)     逆序否定环视，表示所在位置左侧不能匹配括号内正则
>       (?(id/name)yes|no)  若前面指定id或name的分区匹配成功则执行yes处的正则，否则执行no处的正则
>       \number     匹配和前面索引为number的分组捕获到的内容一样的字符串，即分组引用，引用前面分组的文本或匹配结果
>

- **可用的预设特殊字符：**
>       \A  只在字符串开头进行匹配
>       \b  匹配位于开头或者结尾的空字符串
>       \B  匹配不位于开头或者结尾的空字符串
>       \d  匹配任何十进制，等同于 [0-9]
>       \D  匹配非数字字符，[^0-9]
>       \s  匹配任何空白字符，[ \t\n\r\f\v]
>       \S  匹配任何非空白字符，[^ \t\n\r\f\v]
>       \w  匹配任何字母数字字符，[a-zA-Z0-9_]
>       \W  匹配任何非字母数字字符，[^a-zA-Z0-9_]
>       \Z  只在字符串结尾进行匹配
>

- **正则表达式分组：**
>       对于分组而言，整个表达式永远是第0组，然后从左到右，依次为分组编号。
>           从正则表达式左边看，看到的第一个左括号"("表示第一个分组，往右依次类推，第0个分组的隐含的全局表达式
>       re.group(num)和groups()就是为了获取所有的分组
>
>       例如：匹配<title>xxx</title>标签来说，
>           通常这样写：<title>.*</title>
>           可以通过分组，简写：<(title)>.*</\1>      这是一个反向引用的实际应用。\1这种用法，可以引用某组的文本内容。
>           比如：匹配IP地址，
>               \d{1,3}(.\d{1,3}){3}
>               分组简写：(\d{1,3})(.\1){3}      注意：分组引用，仅仅只是引用文本内容，如果引用的是正则表达式，如果前面匹配成功，后面引用的就是匹配的结果，而不是表达式。！！！！！！
>                   因此 (\d{1,3})(.\1){3} 匹配的是四个数相同的IP地址，如：123.123.123.123
>
>       命名分组：
>           上面的是无名分组，当结果有多个分组时，可能需要通过group(num)或groups()去找到我们的分组结果
>           命名分组就是给具有默认分组编号的组另外再给一个名字，语法：
>               (?P<name>正则表达式)#name是一个合法的标识符
>           例如：提取IP地址中，s = "ip='230.192.168.78',version='1.0.0'"
>               则：re.search(r"ip='(?P<ip>\d+\.\d+\.\d+\.\d+).*", s)
>               获取结果：res.group('ip')  通过命名分组找到结果
>
>       分组引用：
>           正则引擎会把被匹配的组按照顺序编号，存入缓存。这样在后面就可以使用"\number"或命名分组进行"(?P=name)"进行引用
>           先进行分组的命名，再进行分组的引用。！！！！
>
>

- **前向、后向断言：**
>       用的就是分组符号，只不过开头都加了一个问号，这个问号局势在说这是一个非捕获组，这个组没有编号，不能用来后向引用，只能当做断言。！！！！！！！！！
>
>       前向肯定断言：
>           (?=pattern)     例如：/w+(?=/d) 与后跟数字的单词匹配，而不与该数字匹配
>       后向肯定断言：
>           (?<=pattern)    例如：(?<=19)99 与跟在 19 后面的 99 的实例匹配
>       例如：
>           获取c语言的注释内容 s1='''char *a="hello world"; char b='c'; /* this is comment */ int c=1; /* this is multiline comment */'''
>           re.findall( r'(?<=/\*).+?(?=\*/)' , s1 ,re.M|re.S)  结果：[' this is comment ', ' this is multiline comment ']
>           解释：(?<=/*)这个是后向肯定断言，表示“/*”之后。(?=*/)这个为前向肯定断言，表示“*/”之前，这两合并起来就是一个区间了，所以后向肯定断言放在前向肯定断言前面
>       注意：如果同时需要用到前向肯定断言和后向肯定断言，那么必须将后向肯定断言写在正则语句的前面，前向肯定断言写在正则语句 ！！！！！
>
>       前向否定断言：
>           (?!pattern)     例如：/w+(?!/d) 与后不跟数字的单词匹配，而不与该数字匹配
>       后向否定断言：
>           (?<!pattern)    例如：(?<!19)99 与不跟在 19 后面的 99 的实例匹配
>       例如：
>           f1 = 'aaa.txt'
>           提取不是.txt结尾的文件名  re.findall(r'.*\..*$(?<!txt$)',f1)  结果：[]
>           提取不以数字开头的文件     re.findall(r'^(?!\d+).*','1txt.txt')    结果：[]
>           提取不以数字开头不以py结尾的文件   re.findall(r'^(?!\d+).+?\..*$(?<!py$)','test.py')   结果：[]
>                                           re.findall(r'^(?!\d+).+?\..*$(?<!py$)','test.txt')  结果：['test.txt']
>

- **python re的其他应用：**
>       1、交互字符串的位置：
>           s = 'abc.xyz'
>           re.sub(r'(.*)\.(.*)', r'\2.\1', s)  #结果：'xyz.abc'
>

- **贪婪与非贪婪：**
>       贪婪匹配：正则表达式一般趋向于最大长度匹配，也就是所谓的贪婪匹配
>       非贪婪匹配：就是匹配到结果就好，就少的匹配字符
>
>
>
>
>
>
>

- **待续：**
>       参考：
>           Python正则表达式操作指南：
>               http://wiki.ubuntu.com.cn/Python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97
>           re – Regular Expressions：
>               https://pymotw.com/2/re/
>           正则表达式在知识提取中的作用(学术上一般是用自然语言处理的方法，但在实践中通常是利用规则)：
>               https://github.com/memect/kg-beijing/wiki/%E7%AC%AC%E4%B8%80%E6%9C%9Fw1%EF%BC%9A%E7%9F%A5%E8%AF%86%E6%8F%90%E5%8F%96
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
