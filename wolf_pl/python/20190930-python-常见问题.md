## python - 常见问题
- **概述：**
>
>

- **is 和 == 的区别：**
>       is：
>           is 的作用是用来检查对象的标示符是否一致，也就是比较两个对象在内存中的地址是否一样
>           is 表示的是对象标示符（object identity）
>           相当于检查 id(a) == id(b)
>           只有 id(a) 和 id(b) 相等时，a is b 才返回 True
>       ==：
>           == 是用来检查两个对象是否相等
>           只要 a 和 b 的值相等，a == b 就会返回True
>           a == b 相当于 a.__eq__(b)，调用了对象 a 的 __eq()__ 方法
>
>       一般情况下，如果 a is b 返回True的话，即 a 和 b 指向同一块内存地址的话，a == b 也返回True，即 a 和 b 的值也相等。
>

- **迭代器和生成器的区别?**
>       实现迭代器的方法称为生成器。这是一个正常的函数，除了它在函数中产生表达式。
>       1、迭代器：
>           迭代器是一个更加抽象的概念，任何对象，如果它的类有next方法和iter方法返回自身。
>           对于string、list、dict、tuple等这类容器对象，使用for循环遍历是很方便的。在后台for语句对容器对象调用iter()函数，iter()是Python的内置函数。
>           iter()会返回一个定义了next()方法的迭代器对象，它在容器中逐个访问容器内元素，next()也是python的内置函数。在没有后续元素时，next()会抛出一个StopIterration的异常。
>       2、生成器：
>           生成器（Generator）是创建迭代器的简单而强大的工具。
>           它们写起来就像是正规的函数，只是在返回数据的时候需要使用yield语句。每次next()被调用时，生成器会返回它脱离的位置（它记忆语句最后一次执行的位置和所有的数据值）
>
>       生成器能做到迭代器能做的所有事，而且因为自动创建了__iter__()和next()方法，生成器显得特别简洁，而且生成器也是高效的，使用生成器表达式取代列表解析可以同时节省内存。
>           除了创建和保持程序状态的自动生成，当发生器终结时，还会自动跑出StopIterration异常。
>
>

- **如何在Python中复制对象？**
>       要在Python中复制对象，可以尝试copy.copy（）或copy.deepcopy（）来处理一般情况。
>       您无法复制所有对象，但大多数对象都是如此。
>

- **Python是如何进行内存管理的？**
>       1、垃圾回收：
>       2、引用计数：
>       3、内存池机制
>
>
>
>
>
>
>
>
>
>
>
>

- **待续：**
>       参考：
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
