### webRTC DTLS
- **概述：**
>       DTLS(Datagram Transport Layer Security)即数据包传输层安全性协议。
>       TLS不能用来保证UDP上传输的数据的安全，因此Datagram TLS试图在现存的TLS协议架构上提出扩展，使之支持UDP，即成为TLS的一个支持数据报传输的版本。
>       DTLS 1.0 基于 TLS 1.1, DTLS 1.2 基于TLS 1.2。
>
>       SSL/TLS协议是基于TCP socket，利用加密、基于数字证书的身份验证等机制在传输层和应用层之间构建了一个端到端的安全通道，保证了传输数据的加密性。
>
>       DTLS协议在UDP提供的socket之上实现了客户机与服务器双方的握手连接，并且在握手过程中通过使用PSK或ECC实现了加密，
>           并且利用cookie验证机制和证书实现了通信双方的身份认证，并且用在报文段头部加上序号，缓存乱序到达的报文段和重传机制实现了可靠传送。
>

- **DTLS与TLS区别：**
>       DTLS握手协议基本与TLS相同，只有三个变化：
>           1、加入一个无状态的cookie交换，以防止dos攻击。
>               (就是给每一个请求连接的IP地址分配一个Cookie，如果短时间内连续受到某个IP的重复报文，就丢弃它)
>           2、修改握手包头来处理丢包，重排序和IP包分片问题。
>           3、重传timer，来处理丢包丢传问题。
>
>

- **使用tcpdump抓包dtls：**
>       tcpdump udp -i eth0 -s 65535 -w handshake.pcap
>

- **DTLS：**
>       DTLS协议在UDP提供的socket之上实现了客户机与服务器双方的握手连接，并且在握手过程中通过使用PSK或ECC实现了加密，
>           并且利用cookie验证机制和证书实现了通信双方的身份认证，并且用在报文段头部加上序号，缓存乱序到达的报文段和重传机制实现了可靠传送。
>
>       在握手完成后，通信双方就可以利用握手阶段协商好的会话密钥来对应用数据进行加解密。
>
>       DLTS协议分为两层：
>           1、下层为记录层（record层）
>           2、record包的内容分为头部和载荷两部分。
>               record包的载荷即为上层的内容。
>
>       DTLS上层的包的类型分为三种：
>           1、握手消息
>           2、警告消息
>           3、应用数据
>

- **TLS：**
>       TLS：Transport Layer Security（安全传输层协议），及其前身安全套接层（Secure Sockets Layer，缩写作SSL）是一种安全协议，
>           目的是为互联网通信提供安全及数据完整性保障。
>
>       SSL/TLS协议是基于TCP socket，利用加密、基于数字证书的身份验证等机制在传输层和应用层之间构建了一个端到端的安全通道，保证了传输数据的加密性。
>
>       安全传输层协议（TLS）用于在两个通信应用程序之间提供保密性和数据完整性。
>
>       该协议由两层组成：
>           1、TLS 记录协议（TLS Record）
>               较低的层为 TLS 记录协议，位于某个可靠的传输协议（例如 TCP）上面。
>           2、TLS 握手协议（TLS Handshake）
>
>
>       TLS 的最大优势就在于：
>           TLS 是独立于应用协议。高层协议可以透明地分布在 TLS 协议上面。
>
>       TLS包含三个基本阶段：
>           1、对等协商支援的密钥算法
>           2、基于私钥加密交换公钥、基于PKI证书的身份认证
>           3、基于公钥加密的数据传输保密
>

- **dtls细节：**
>       客户机向服务器发起连接，服务器可以根据配置选择是否验证客户机的cookie和证书（即是否向客户机发送client_hello_verify和certificate_request报文段）。
>
>       client_hello：
>           client_hello报文段的内容除cookie外，还有客户机产生的32字节的随机数，其中前4字节为时间戳，后28字节为系统产生的随机数。
>               生成一个32字节随机数。最后加密数据用的主密钥，需要客户端和服务端一起协商出来。后面服务端的 Server Hello 阶段也会生成一个随机数。一同用来计算出主密钥。
>           此外，该报文段的内容还有客户机支持的加密方式（PSK或者ECC）和压缩方式，供服务器进行选择。
>               一共应用了三种密钥技术，非对称密钥，对称密钥和摘要算法。用一句话总结：用非对称加密算法来传递对称加密算法的密钥，同时用摘要算法保证数据的完整性。
>
>       server_hello：
>           该报文段包含有服务器产生的32字节的随机数，和服务器选中的用来进行之后的会话的加密方式和压缩方式。
>               上面的 Client Hello 过程也生产了一个 32 位随机数，这两个随机数将参与主密钥（master key）的创建。
>           通过cookie校验后，服务器发送server_hello报文段给客户机。
>       certificate：
>           在服务器发给客户机的证书报文段中，包含有服务器证书的公钥
>           客户机接收到该报文段后，按照协议规定，从报文段的对应位置中读取出服务器证书的公钥存入相关变量中。
>       server_key_exchange：
>           客户机在收到server_key_exchange报文段后，先进行各数值项格式的校验，然后提取出报文段末尾的签名值r和s。
>           之后，用已经读取出的服务器的公钥的x,y坐标值来对server_key_exchange报文段进行ECDSA签名验证，若结果和报文段中的r和s值一致，则报文段通过验证。
>       certificate_request：
>           略
>       certificate_verify：
>           发送这个类型的握手需要2个前提条件
>               1、服务器端请求了客户端证书
>               2、客户端发送了非0长的证书
>               此时，客户端想要证明自己拥有该证书，必然需要私钥签名一段数据发给服务器验证
>           签名的数据是客户端发送certificate verify前，所有收到和发送的握手信息（不包括5字节的record）。
>           其实这个流程和签名server key exchange基本一样。计算摘要，然后签名运算。
>       server_hello_done：
>           服务器发送的server_hello_done报文段的载荷部分为空，只是发给客户机来作为标志，表示服务器当前阶段的报文段已经发送完毕。
>           客户机在收到server_hello_done报文段后，发送client_key_exchange报文段给服务器，里面包含了用于秘钥协商的基点的x,y坐标,
>               并且不同于server_key_exchange报文段，客户机并没有在报文段的末尾进行ECDSA数字签名。
>       client_key_exchange：
>       server_key_exchange：
>           整个DTLS协议的加密方式可选用ECC或PSK（预共享秘钥，PreSharedKey）两种：
>               1、若为ECC，则通过ECDH协议来进行通信双方的秘钥协商；
>               2、若为PSK，则直接以通信双方事先就已经约定好了的秘钥为基础来进行加密通信
>           采用PSK与ECC的区别主要体现在server_key_exchange报文段、client_key_exchange报文段的内容不同和双方计算得到预主秘钥方式的不同。
>
>           一：若协议所选加密方式为ECC
>           1、若协议所选加密方式为ECC（椭圆曲线加密），则在server_key_exchange报文段的构造过程中会使用ECDH（椭圆曲线秘钥交换协议）和ECDSA（椭圆曲线数字签名算法）。
>               ECDH和ECDSA分别是ECC和DH（diffie-hellman）秘钥交换协议、DSA（数字签名算法）的结合。
>           2、在server_key_exchange报文段中，包含有所选用的椭圆曲线E，阶N和基点G的x,y坐标，客户机在收到这个报文段后，进行对应的格式检验，并读取数据，
>               因此服务器和客户机共同获得约定好的用来进行ECDH秘钥协商交换协议的参数，从而可以共同协商出相同的对话秘钥用于加密之后的会话内容。
>           3、为了防范中间人攻击，服务器还在server_key_exchange报文段的末尾对整个报文段进行了ECDSA数字签名。
>               具体签名过程为先用client_hello报文段和server_hello报文段中的2个32字节的随机数作为函数参数，利用sha256哈希算法对server_key_exchange报文段本身的载荷产生摘要，
>               然后再用服务器的私钥和sha256哈希算法进行ECDSA数字签名，得到签名结果r和s,并写入server_key_exchange报文段的末尾。
>           4、客户机在收到server_key_exchange报文段后，先进行各数值项格式的校验，然后提取出报文段末尾的签名值r和s。
>               之后，用已经读取出的服务器的公钥的x,y坐标值来对server_key_exchange报文段进行ECDSA签名验证，若结果和报文段中的r和s值一致，则报文段通过验证。
>
>           二：若为PSK，则直接以通信双方事先就已经约定好了的秘钥为基础来进行加密通信。
>           1、对于PSK加密通信来说，验证对方的通信身份非常关键。所以通信双方会在本地存取对方的psk_id（即身份标志）和psk_id_length（身份标志长度）
>               通过比较收到的报文段中的psk_id,psk_id_length和本地存储的是否完全一致来进行对方身份的验证。
>           2、server_key_exchange报文段和client_key_exchange报文段的内容分别是服务器与客户机各自的psk_id和psk_id_length，由此双方可以互相知道对方的psk_id和psk_id_length。
>           3、双方都会对收到的报文段进行检验，只有psk_id和psk_id_length与本地存储的完全一致才会进行后面的通信。
>           4、当双方都通过身份验证后，双方再各自用相同的函数产生预主秘钥，而函数的参数包括之前通信阶段中双方各自产生的32字节的随机数，由此可以保证虽然本地存储的psk秘钥不变，
>               但每次临时通信时的会话秘钥还是会一直变化的，从而增强了抗攻击性。
>           5、双方产生预主秘钥后，再调用和使用ECC加密的相同方式来产生主秘钥，即用于之后会话通信的对称秘钥，该过程中依然会用到双方产生的32字节的随机数。
>           6、通信双方使用PSK加密方式来实现了身份认证和会话秘钥的产生。
>
>       change_cipher_spec：
>           客户机计算出会话秘钥后，发送change_cipher_spec报文段给服务器，这个报文段的有效载荷为空，用来作为标志通知服务器，
>               表示客户机已经算出主秘钥，之后发送的报文段会采用主秘钥加密。
>
>       交互过程：（带()表示可选消息）
>       client_hello            ->  ........................cookie、32字节的随机数、支持的加密方式（PSK或者ECC）和压缩方式
>                               <-  server_hello............32字节的随机数、选择的加密方式和压缩方式
>                               <-  certificate.............含有服务器证书的公钥
>                               <-  server_key_exchange.....见上文
>                               <-  (certificate_request)
>                               <-  server_hello_done.......载荷部分为空，只是发给客户机来作为标志，表示服务器当前阶段的报文段已经发送完毕。
>       (certificate)           ->
>       client_key_exchange     ->..........................包含了用于秘钥协商的基点的x,y坐标，不同于server_key_exchange报文段，并没有在报文段的末尾进行ECDSA数字签名
>       (certificate_verify)    ->
>       change_cipher_spec      ->..........................客户机计算出会话秘钥后发送的报文，报文段的有效载荷为空，用来作为标志通知服务器，表示客户机已经算出主秘钥，之后发送的报文段会采用主秘钥加密
>       finished                ->..........................载荷内容为MAC值（消息验证码），用于给服务器做认证。finished报文段作为记录层的载荷部分在发送时已经用上一步产生的会话秘钥进行加密编码。
>                               <-  change_cipher_spec......客户机计算出会话秘钥后发送的报文，报文段的有效载荷为空，用来作为标志通知服务器，表示客户机已经算出主秘钥，之后发送的报文段会采用主秘钥加密
>                               <-  finished................载荷内容为MAC值（消息验证码），用于给服务器做认证。finished报文段作为记录层的载荷部分在发送时已经用上一步产生的会话秘钥进行加密编码。
>
>       客户机再通过ecdh_pre_master_secret函数来产生用于之后会话的预主秘钥。其中函数的参数包括客户机自己的私钥，和服务器共享的用于ECDH秘钥协商算法的基点的x,y坐标。
>           产生预主秘钥后，再根据之前阶段客户机和服务器分别产生的32字节的随机数产生主秘钥master_secret，此时主秘钥为对称秘钥，用于之后会话的加解密。
>

- **SSL应用：**
>       SSL 握手的流程并不是一成不变的，根据实际的应用场景来。主要有三种：
>           1、只验证服务端。
>               这个用三个阶段就完成握手，我们这次的请求也是这样。一般的网络请求也仅仅到这个程度。
>           2、验证服务端和客户端。
>               在安全性要求较高的场景，服务端也要验证客户端的身份。方式也是发证书证明自己。
>           3、恢复原有会话 。
>               这个属于HTTPS 优化的范畴。使用 Session Ticket 或者 Session ID 机制恢复之前已经完成握手的会话。这个是可以允许在不同的 TCP 上进行的。
>               因为握手的加密数据已经保存，直接恢复就可以开始传递了。Session Ticket 由客户端保存加密信息，Session ID 的方式由服务端保存加密信息。
>               不过 Session Ticket 在 Android 客户端还没有得到广泛的支持，和具体机型和内置的 OpenSSL 的版本有关。
>

- **SSL 握手阶段的主要目的：**
>       1、协商加密算法。
>           为了能够提供效率，使用对称密钥。对称加密使用的是位运算，速度快，甚至可以硬件加速。
>           非对称加密比如 RSA，使用了大数乘法等，整体会比较慢。
>           对称加密只要密钥没有泄漏，那也是非常安全的。这也是后面 SSL 握手协议要确保的。
>       2、协商加密密钥 。
>           用来对后面的 HTTP 协议等应用协议内容进行加密。这个密钥又称为主密钥，为加密算法的密钥。
>       3、验证身份 。
>           通常情况下，只要验证服务端身份。
>           特殊情况下，比如一些安全级别高的应用场景，还要验证客户端身份。
>           服务端会返回证书链，有根 CA 证书在里头。通过证书的链式担保，可以确认服务端是否是可信任的。
>           同时，在握手期间，公钥传输成功后，还会对某些信息进行数字签名，确保数据没有被篡改且身份无误。
>

- **SSL握手交互过程：**
>       SSL 握手的完整的交互过程如下，这里是验证服务端又验证了客户端的情况
> ![avatar](https://github.com/nwaiting/wolf-ai/blob/master/wolf_others/pl_pic/network_ssl.jpg)
>
>

- **证书生成和验证：**
>       生成证书：
>           1、用工具生成一对公钥和私钥
>           2、构造证书，把公钥嵌入到证书里面（即证书里面其实有一个字段是公钥，明文的）
>           3、最重要的一步，谷歌拿自己的根证书签名一个第三步构造好的证书
>               所谓签名：就是对第三步的证书做摘要，MD5或者SHA1，或者MD5+SHA1，得到结果，然后拿自己根证书的私钥加密这个结果，然后添加到证书最后面。
>           4、把证书和私钥交给你
> ![avatar](https://github.com/nwaiting/wolf-ai/blob/master/wolf_others/pl_pic/network_ssl_certificate.png)
>
>
>       证书验证：
>           如果有一个客户端，访问我们的网站，我们发送我们的证书给客户端，客户端如何验证呢？
>           1、对我们的证书（除了“签名值”）全部内容进行MD5/SHA1，得到一个结果1
>           2、用“Google”证书中的公钥，对我们证书中的“签名值”进行解密，得到结果2
>           3、比较结果1 和结果2 ，发现一样，那么认证通过。理论上，如果中间没人改动我们的证书，那么，结果1和结果2 都是“asdfghjklqwertyu”。
>
>       自己证书中的公钥和私钥在ssl握手中使用：
>           1、把“www.dp.com”证书发给客户端，客户端的确认证了，然后客户端用“www.dp.com”证书中的公钥加密一个密钥，按握手要求，服务器需要用私钥来解密，
>               可是我没有对应私钥，以没办法解密！后面的会话都解密不了，即SSL握手完成不了。
>           2、SSL协议规定，服务器在握手时，需要用私钥签名握手数据（server key exchange），客户端需要用公钥验证这个签名的握手数据。
>               可见，如果服务器没有私钥，那么也就不能完成签名这步，或者签名的值客户端无法验证，握手无法继续。
>           3、证书发给客户端，客户端找到叫做“Google”的证书，拿它的公钥解密这个签名值，问题来了，这个由于这个签名值是由我刚才假冒的“Google”证书的私钥签名的，
>               所以，正宗的“Google”正宗的公钥解密得到的结果，压根不是“asdfghjklqwertyu”，当客户端对我们这个证书做摘要，结果是“asdfghjklqwertyu”，
>               但是对签名解密的结果却是另外一个值，那么浏览器就不信任你了。
>

- **相关概念：**
>       加密解密：
>           公钥加密数据,然后私钥解密的情况被称为加密解密
>       签名和验证签名：
>           私钥加密数据,公钥解密一般被称为签名和验证签名。本质上是一样，叫法不同
>       应用流程：
>           AB双方交换公钥,然后A要发给B的数据,用B的公钥加密,B得到后用他的私钥解密,同理B要发给A的数据,用A的公钥加密,A收到到后用A私钥解密。
>
>       SSL：（Secure Socket Layer，安全套接字层）：
>           位于可靠的面向连接的网络层协议和应用层协议之间的一种协议层。SSL通过互相认证、使用数字签名确保完整性、使用加密确保私密性，以实现客户端和服务器之间的安全通讯。
>           该协议由两层组成：SSL记录协议和SSL握手协议。
>       TLS：(Transport Layer Security，传输层安全协议)：
>           用于两个应用程序之间提供保密性和数据完整性。该协议由两层组成：TLS记录协议和TLS握手协议。
>
>

- **待续：**
>       参考：https://www.cnblogs.com/kernel_hcy/p/3694807.html    在libuv中使用openssl建立ssl连接
>           https://blog.csdn.net/ddr77/article/details/84583101    licode(三）：流媒体数据怎么转发
>           https://michaelyou.github.io/2018/08/01/%E7%9C%9F%E5%AE%9E%E4%B8%96%E7%95%8C%E4%B8%AD%E7%9A%84WebRTC/   真实世界中的WebRTC：STUN, TURN and signaling
>           https://segmentfault.com/a/1190000006233845#articleHeader11     DTLS协议中client/server的认证过程和密钥协商过程
>           https://www.jianshu.com/p/cf8c2f2cd18a  Wireshark 抓包理解 HTTPS 请求流程
>           https://blog.csdn.net/umqoa842820/article/details/54880426   DTLS-PSK算法抓包解析
>           https://www.jianshu.com/p/cf8c2f2cd18a  Wireshark 抓包理解 HTTPS 请求流程
>           https://www.cnblogs.com/littleatp/p/6358261.html    DTLS 技术要点解析
>           http://seanlook.com/2015/01/07/tls-ssl/     SSL/TLS原理详解
>           https://imququ.com/post/optimize-tls-handshake.html     TLS 握手优化详解
>           https://blog.csdn.net/mrpre/column/info/17425/1     SSL/TLS协议详解（带wireshark分析）
>           https://blog.csdn.net/mrpre/article/details/77867063    TLS/SSL 协议详解(6) SSL 数字证书的一些细节1 证书验证
>
>
>
>
>
>
>
>
