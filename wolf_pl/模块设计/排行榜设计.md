## 排行榜设计
- **概述：**
>       排行榜设计主要注重性能，所以存储的数据结构和排序更新策略非常重要
>
>

- **常用的数据结构和算法：**
>       方法1：
>           redis中的sort set的实现
>           ZSET的实现用到了两个数据结构：hash table 和 skip list(跳跃表)，
>               其中hash table是具体使用redis中的dict来实现的，主要是为了保证查询效率为O(1) ，
>               而skip list(跳跃表)主要是保证元素有序并能够保证INSERT和REMOVE操作是O(logn)的复杂度。
>
>       方法2：
>           Treap、RankTree（名次树）
>           实际上是一个在区间树上由上至下、由粗到细一步步明确s所在位置的过程
>           结构稳定，不受积分分布影响；每次查询或更新的复杂度为积分最大值的O(log(n))级别，且与用户规模无关，可以应对海量规模；
>               不依赖于SQL，容易改造为NoSQL或内存数据结构
>
>       方法3：
>           排名数组
>           方法2虽然性能较高，达到了积分变化的O(log(n))的复杂度，但是实现上比较复杂。另外，O(log(n))的复杂度只在n特别大的时候才显出它的优势，
>               而实际应用中积分的变化情况往往不会太大，这时和O(n)的算法相比往往没有明显的优势，甚至可能更慢。
>           考虑到这一情况，仔细观察一下积分变化对排名的具体影响，可以发现某用户的积分从s变为s+n，积分小于s或者大于等于s+n的其他用户排名实际上并不会受到影响，
>               只有积分在[s,s+n)区间内的用户排名会下降1位。我们可以用于一个大小为1,000,000的数组表示积分和排名的对应关系，其中rank[s]表示积分s所对应的排名。
>               初始化时，rank数组可以由user_score表在O(n)的复杂度内计算而来。用户排名的查询和更新基于这个数组来进行。
>               查询积分s所对应的排名直接返回rank[s]即可，复杂度为O(1)；当用户积分从s变为s+n，只需要把rank[s]到rank[s+n-1]这n个元素的值增加1即可，复杂度为O(n) 
>
>
>
>
>
>
>
>
>
>

- **待续：**
>       参考：https://blog.codingnow.com/2014/03/mmzb_db_2.html    谈谈陌陌争霸在数据库方面踩过的坑(排行榜篇)
>           https://gameinstitute.qq.com/community/detail/101951    排行榜算法设计实现比较
>
>
>
>
>
>
>
>
>
>
>
