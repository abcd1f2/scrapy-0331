## 深入理解计算机系统 - CPU性能 - 中断
- **概述**
>       中断其实就是一种异步的事件处理机制，可以提高系统的并发处理能力
>

- **中断的丢失问题：**
>       中断处理程序在相应中断时，会临时关闭中断，这就导致在处理中断过程中，其他中断不能响应，就是中断有可能会丢失。
>       linux解决中断丢失问题：
>           1、将中断处理过程分成两个阶段
>               a、上半部分用来快速处理中断（类似于接收中断）
>               b、下半部分用来延迟处理上半部分未完成的工作（处理中断逻辑，通过内核线程的方式运行）
>           比如网卡接收数据包的上本部分和下半部分：
>               a、上半部分，把网卡的数据读到内存中，然后更新硬件寄存器的状态（标识数据已经读好了），然后在发送一个软中断信号，通知下半部分做进一步处理
>               b、被软中断信号唤醒，然后从内存中找到网络数据，在按照网络协议栈，对数据进行逐层解析和处理，直到输送道应用程序
>

- **软中断**
>       软中断类型：
>           软中断包括10个类别，分别对应不同的工作类型
>           10种类别：
>               HI              最高优先级的软中断类型
>               TIMER           Timer定时器软中断
>               NET_TX          发送网络数据包软中断
>               NET_RX          接收网络数据包软中断
>               BLOCK
>               BLOCK_IOPOLL    块设备软中断
>               TASKLET         专门为tasklet机制准备的软中断
>               SCHED           进程调度以及负载均衡软中断
>               HRTIMER         高精度定时器软中断
>               RCU             RCU服务软中断
>
>
>       软中断注意事项：
>       1、TASKLET是最常见的软中断实现机制，每个TASKLET只运行一次就会结束，并且只在调用它的函数所在的CPU上运行。
>           TASKLET在不同CPU上的分布并不均匀，因为使用TASKLET特别简便，当然也会存在一些问题，
>           比如说由于只在一个cpu上运行导致调度不均衡，再比如因为不能在多个CPU上并行运行带来了性能限制
>
>       2、软中断是以内核线程的方式运行的，每个CPU都对应一个软中断内核线程，这个软中断内核线程叫做ksoftirqd/CPU 编号。
>           一般来说，ps 的输出中，名字括在中括号里的，一般都是内核线程。
>           这些线程的名字外面都有中括号，这说明ps无法获取他们的命令行参数（cmline）。
>
>       静态和动态观察如中断情况：（各类软中断次数是系统运行以来的累积中断次数）
>           cat /proc/softirqs
>           watch -d cat /proc/softirqs
>
>       使用softirqs查看到网络中断情况后，然后可以使用tcpdump对网络进行抓包分析
>

- **观察系统的网络接收情况：**
>       sar可以用来查看系统的网络接收情况
>       不仅可以观察网络收发的吞吐量(BPS,每秒收发的字节数)，还可以观察网络收发的PPS，即每秒收发的网络帧数
>           -n DEV 表示显示网络收发的报告，间隔 1 秒输出一组数据
>           sar -n DEV 1
>

- **总结：**
>       1、从系统的软中断使用率高这个现象出发，
>       2、观察/proc/softirqs 文件的变化情况，判断出软中断类型是网络接收中断
>       3、再通过 sar 和 tcpdump ，确认这是一个 SYN FLOOD问题
>
>

- **软中断和硬中断：**
>       硬中断是硬件产生的,比如键盘、鼠标的输入，硬盘的写入读取、网卡接收发送数据（网卡的处理实际是有硬中断和软中断的）
>       软中断是软件产生的，比如程序内的定时器、RCU锁
>

- **软中断案例分析：**
>       之前的c程序用到了别人写的动态库[如:lib.a]，在物理机上，进程的cpu利用率在0%；而切换到了云服务器，即使空载，单进程的cpu利用率都有30%+。
>       后来才通过vmstat 检测到系统的软中断每秒有100W+次
>       最后才发现是那个动态库在处理网络收发消息时,使用了usleep(1)来休息,每次休息1纳秒,单次中断的耗时都不止1纳秒
>
>
>
>

- **待续：**
>       参考：https://www.cnblogs.com/luoahong/p/10820252.html     Linux性能优化实战学习笔记：第十讲
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
