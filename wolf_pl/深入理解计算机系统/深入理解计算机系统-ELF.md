## 深入理解计算机系统 - ELF文件详解
- **概述**
>       ELF最初由unix系统实验室(USL)做为应用程序二进制接口(ABI)的一部分而制定和发布。
>       ELF最大特点在于它有比较广泛的适用性，通用的二进制接口使之可以平滑地移植到多种不同的操作系统上。
>
>       ELF文件格式分为三种：
>           1、可重定位的目标文件，通常为后缀为.o的目标文件
>               如果引用一个外部目标文件或库文件定义的符号（函数或变量）的话，知识给出一个名字，但是不知道符号的具体地址在哪里，
>               因此需要在链接的过程中，把对这些外部符号的引用重新定位到其真正定义的位置，所以称目标文件为可重定位或待重定位。
>           2、可执行文件
>           3、共享文件，通常为后缀为.so的目标文件
>               以下两种情况下被使用：
>                   a、在链接过程中与其他动态链接库或可重定位文件一起构建新的目标文件
>                   b、在可执行文件被加载的过程中，被动态链接到新的进程中，成为运行代码的一部分
>
>       注意：
>           1、linux中readelf可以查看ELF文件的详细信息
>           2、ELF文件只能在操作系统环境下运行，逻辑环境运行的是BIN文件，编译器默认输出的文件格式是ELF格式，可以使用objcopy命令转化为BIN文件
>               arm-linux-objcopy -O binary name.elf name.bin
>

- **ELF组成：**
>       目标文件参与程序链接和程序执行。为了方便和效率，目标文件为链接程序和执行程序提供了不同的视角。
>       即：目标代码文件和可执行文件的内容布局是不同的
>       目标代码文件：
>           1、由section组成
>               汇编程序中的.text,.bss,.data这些提示，都指的是section。如.text，告诉汇编器后面的代码放入.text section中
>               section和section header table中的条目是一一对应的。section的信息用于链接器对代码重定位。
>       可执行文件：
>           1、由segment组成
>               文件载入内存执行时，是以segment组织的，每个segment对应ELF文件中program header table中的一个条目，用来建立可执行文件的进程映像
>               比如常说的，代码段、数据段都是segment，目标代码中section会被链接器组织到可执行文件的各个segment中。
>
>

- **ELF常见组成部分：**
>       1、ELF header
>           保存在文件最顶端，记录了整个文件的基本信息
>       2、Sections
>           包含了链接视角中每个节中的信息：指令、数据、符号表、重定位信息等等
>       3、section header table
>           包含描述文件节的信息，每个节对应表中的一项，包含节名、节的大小信息等
>           节头表 包含了文件中所有节的信息，在链接布局中，节头表是必须存在的，文件里的每一个节都需要在节头表中有一个对应的注册项，这个注册项描述了节的名字、大小等。
>       4、segment
>           包含了执行视角中的每个段(程序数据和指令)文本段、数据段等
>       5、program header table
>           描述了一个段的信息或者系统准备程序运行环境时所需要的其他信息
>           程序头表 在运行过程中是必须的，在链接过程中是可选的，因为它的作用是告诉系统如何创建进程的镜像
>           程序头指明了文件中各个段的位置，还包含一些用于创建内存镜像的必要内容。
>

- **解析过程：**
>       符号表
>       如果一个可执行文件中含有一个函数的引用，而这个函数是定义在一个共享目标文件中，那么在可执行文件中，针对那个共享目标文件的符号表应该含有这个函数的符号。
>       符号表的st_shndx成员值为SHN_UNDEF，这就告诉了动态链接器，这个函数的符号定义并不在可执行文件中。
>

- **重定位：**
>       重定位是把符号引用与符号定义链接在一起的过程。
>       比如，当程序调用一个函数时，将从当前运行的指令跳转到一个新的指令地址去执行。
>       在编写程序的时候，只需要指明所要调用的函数名（即符号索引），在重定位的过程中，函数名会与实际的函数所在地址（即符号定义）联系起来，使程序知道应该跳转到哪里
>
>       重定位节：
>           一个重定位节需要引用另外两个节：
>               1、符号表节
>               2、被修改节
>           r_offset成员：
>               1、在重定位文件中，r_offset成员含有一个节偏移量。重定位节本身描述的是如何修改文件中的另一个节的内容，重定位偏移量(r_offset)指向了另一个节中的一个存储单元地址。
>               2、在可执行文件或共享目标文件中，r_offset含有的是符号定义在进程空间中的虚拟地址。可执行文件和共享目标文件是用于运行程序而不是构建程序的，
>                   所以对它们来说更有用的信息是运行期的内存虚拟地址，而不是某个符号定义在文件中的地址
>
>       可执行文件生成过程：
>           连接编辑器要把一个或多个可重定位文件合并成一个可执行文件或共享目标文件作为输出。
>           首先，需要决定如何把输入文件组合起来，并定位其中的符号，然后更新符号值，最后实现重定位。
>
>       函数链接表项：
>           函数链接表项把函数调用定位到合适的位置。
>           在构建期间，链接编辑器创建初始的函数链接表；
>           在运行期间，动态链接器会修改表项
>

- **ELF文件的装载和链接：**
>       准备一个程序的内存镜像，大体上分为装载和链接两个步骤：
>       装载：
>           主要是把目标文件装载入内存
>           程序装载就是操作系统创建和扩充进程镜像的过程
>           进程在加载完成后，很多文件的内容其实并没有真正地映射到内存中，进程只有在真正需要去访问一个内存页面的时候，才会去映射它，这样提高了系统的性能和效率。
>           为了达到提高效率的效果，可执行文件和共享目标文件中段的镜像在文件中的偏移量或者内存虚拟地址必须是向页面大小对齐的。
>               如Intel架构中，页面大小为4KB，所以段的虚拟地址和文件内偏移量要向4KB或者4KB整数倍对齐，这样便于整页的换入和换出，提高效率。
>           当装载进内存后，未初始化的全局变量会被放在紧跟在数据段的后面，系统一般会把这种数据置为0.
>
>           1、一方面，在可执行文件中，要包含绝对地址。运行期间的段的虚拟地址必须与构建可执行文件时该段的地址相同。系统使用p_vaddr来记录不变的虚拟地址。
>               在程序开始执行以前，动态链接器会为内存镜像做重定位，更新绝对地址。
>               当库文件在被装载时，如果其内存地址与其文件中描述的完全相同的话，那些引用他们的绝对地址就是对的，不需要更新。实际上，这种情况很少发生。
>           2、另一方面，在共享目标文件中，要使用地址无关的代码，不能依赖于绝对地址。
>
>       链接：
>           动态链接就是解析目标文件中的符号引用的过程，在进程初始化和进程运行期间都可能发生。
>
>
>       动态链接器：
>           当创建一个可执行文件时，如果依赖其他的动态链接库，那么链接编辑器会在可执行文件的程序头中加入一个PT_INTERP项，告诉系统这里需要使用动态链接器。
>           可执行文件与动态链接器一起创建了进程的镜像，包含以下过程：
>               1、添加可执行文件的段到进程空间
>               2、添加共享目标文件的段都进程空间
>               3、为可执行文件和共享目标文件进行重定位
>               4、如果动态链接器使用了可执行文件的文件描述符，应该关闭它
>               5、把控制权交给程序
>

- **动态段：**
>       如果目标文件参与动态链接，它的程序头表中一定会包含一个类型为PT_DYNAMIC的表项，其所对应的段称为动态段（dynamic segment），段的名字为.dynamic。
>       动态段的作用是提供动态链接器所需要的信息，比如依赖于哪些共享目标文件、动态链接符号表的位置、动态链接重定位表的位置等
>

- **共享目标的依赖关系：**
>       动态链接器为一个目标文件创建内存段的时候，动态结构中的DT_NEEDED项会指明锁依赖的库，动态链接器会链接被引用的符号和它们锁依赖的库，这个过程会反复地执行，直到一个完整的进程镜像被构建好。
>       查找符号表规则：！！！
>           动态链接器以一种广度优先算法来查找符号表。
>           1、首先链接器查找可执行程序自己的符号表
>           2、然后查找DT_NEEDED项所指明的库的符号表
>           3、在接下来是下一层依赖的符号表，依次下去
>       注意：共享目标文件必须是可读的，其他权限没有要求
>
>       动态连接器 库文件查找优先级：
>           1、首先查找 动态数组标记DT_RPATH可能给出一系列目录名的字符串
>           2、然后查找 LD_LIBRARY_PATH系统设置的路径
>           3、如果上面两个都无法找到所要的库，则搜索/usr/lib 系统目录
>

- **全局偏移量表：**
>
>

- **函数地址：**
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>

- **待续：**
>       参考：
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
