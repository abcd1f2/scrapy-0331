## 深入理解计算机系统 - 内存性能
- **概述**
>       缺页异常常见有两种情况：
>           1、次缺页异常，分配物理内存
>           2、主缺页异常，需要磁盘I/O介入（Swap机制）
>
>       查看内存常用工具：
>           1、free
>           2、vmstat
>           3、cachestat     #系统缓存的读写命中情况
>           4、cachetop      #每个进程缓存的读写命中情况
>           5、memleak 
>

- **Buffers和Cache的区别：**
>       Buffers 是内核缓冲区用到的内存，对应的是/proc/meminfo 中的 Buffers 值
>           Buffers 是对原始磁盘块的临时存储，也就是用来缓存磁盘的数据，通常不会特别大(20MB左右)，这样，内核就可以把分散的写集中起来统一优化磁盘的写入，
>           比如可以把多次小的写合并成单词大的写等等
>       Cache 是内核页缓存和 Slab 用到的内存，对应的是/proc/meminfo 中的 Cached 与 与 SReclaimable 之和
>           Cached 是从磁盘读取文件的页缓存，也就是用来缓存从文件读取的数据。这样，下次访问这些文件数据时，就可以直接从内存中快速获取，而不需要再次访问缓慢的磁盘。
>       SReclaimable：
>           SReclaimable 是 Slab 的一部分。Slab包括两部分，其中的可回收部分，用 SReclaimable 记录；而不可回收部分，用 SUnreclaim 记录
>
>       总结：
>           简单来说，Buffer 是对磁盘数据的缓存，而 Cache 是文件数据的缓存，它们既会用在读请求中，也会用在写请求中。
>       写文件时会用到 Cache 缓存数据，而写磁盘则会用到Buffer 来缓存数据。所以，回到刚刚的问题，虽然文档上只提到，Cache 是文件读的缓存，但实际上，Cache 也会缓存写文件时的数据
>
>

- **减少页表的项数：**
>       页的大小只有4KB，导致另一个问题就是，整个页表会变得非常大。32位系统需要1M个页表项，才可以实现整个地址空间的映射。
>       为了解决页表项过多的问题，linux提供了两种机制，即多级页表和大页（HugePage）。
>           1、多级页表
>               就是把内存分成区块来管理，将原来的映射关系改成区块索引和区块内的偏移
>           2、大页
>               常见的大小有2MB和1GB。大页通常用在使用大量内存的进程上，比如Oracle、DPDK等
>

- **虚拟内存分布简介：**
>       从地地址到高地址分布为：
>           1、只读段
>               代码、常量区
>           2、数据段
>               全局变量区
>           3、堆
>               动态内存分配（从地地址向上增长）
>           4、文件映射段
>               动态库、共享内存等（从高地址向下增长）
>           5、栈
>               栈的大小固定，一般为8M
>
>       5个内存段中，堆和文件映射的内存是动态分配的。
>           比如：使用malloc和mmap，就可以在堆和文件映射段分配内存
>
>       malloc是C的标准库提供的内存分配函数，对应到系统调用上，有两种实现：brk和mmap
>           brk：
>               小块内存分配，释放后不会立刻归还系统，而是被缓存起来，重复使用
>           mmap：
>               大块内存分配，就是在文件映射段找一块空闲内存分配出去，在释放时直接归还系统，所以每次都会发生缺页异常。
>               频繁的分配会导致大量的缺页异常，是内核的管理负担增大
>

- **内存回收：**
>       系统不会任由某个进程用完所有内存，在发现内存紧张时，系统就会通过一系列机制来回收内存，常见方法：
>           1、回收缓存
>               比如使用LRU算法，回收很少使用的内存
>           2、回收不常访问的内存
>               通过把不常用的内存通过交换分区swap到磁盘
>           3、杀死进程
>               系统还会通过OOM，直接杀掉进程
>               OOM机制：
>                   a、进程消耗的内存越大，oom_score越大，越容易被OOM杀死
>                   b、进行运行占用的CPU越多，oom_score就越小，越不容易被OOM杀死
>               比如：实际工作的需要，管理员可以通过 /proc 文件系统，手动设置进程的 oom_adj ，从而调整进程的 oom_score。
>                     oom_adj 的范围是 [-17, 15]，数值越大，表示进程越容易被 OOM 杀死；数值越小，表示进程越不容易被 OOM 杀死，其中 -17 表示禁止 OOM。
>                     比如用下面的命令，你就可以把 sshd 进程的调小为 -16，这样， sshd 进程就不容易被 OOM 杀死
>                     echo -16 > /proc/$(pidof sshd)/oom_adj
>

- **磁盘和文件的区别：**
>       磁盘是一个块设备，可以划分为不同的分区；在分区之上再创建文件系统，挂载到某个目录，之后才可以在这个目录中读写文件。
>           1、在读写普通文件时，会经过文件系统，由文件系统负责与磁盘交互；
>           2、而读写磁盘或者分区时，就会跳过文件系统，也就是所谓的“裸I/O“
>           这两种读写方式所使用的缓存是不同的，也就是文中所讲的 Cache 和 Buffer 区别
>

- **perf使用：**
>       权限配置：（如果有权限问题）
>           可以通过配置 /proc/sys/kernel/perf_event_paranoid 许非特权用户执行 perf 事件分析
>
>       perf使用步骤：
>           1、采集数据
>               perf record -e cpu-clock -g -p 28591
>           2、查看报告
>               perf report -i perf.data
>
>       strace 追踪进程的堆栈
>           比如：strace -p $(pgrep app)
>
>
>
>
>
>
>
>
>

- **待续：**
>       参考：
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
