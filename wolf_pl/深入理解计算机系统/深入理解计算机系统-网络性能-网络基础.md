## 深入理解计算机系统 - 网络性能 - 网络基础
- **概述**
>
>       常用命令：
>           1、hping3
>               hping3 作为一个 SYN 攻击的工具来使用
>               hping3 更多的用途，是作为一个测试网络包处理能力的性能工具
>           2、pktgen
>               Linux 内核自带的高性能网络测试工具 pktgen
>               pktgen 支持丰富的自定义选项，方便你根据实际需要构造所需网络包，从而更准确地测试出目标服务器的性能
>               在 Linux 系统中，你并不能直接找到 pktgen 命令。因为 pktgen 作为一个内核线程来运行，需要你加载 pktgen 内核模块后，再通过 /proc 文件系统来交互
>               pktgen 在每个 CPU 上启动一个内核线程，并可以通过 /proc/net/pktgen 下面的同名文件，跟这些线程交互；而 pgctrl 则主要用来控制这次测试的开启和停止
>
>
>
>

- **OSI模型：（七层模型）**
>       OSI（OpenSystem Interconnection Reference Model） 网络模型：（七层模型）
>           这些层都来自国际标准化组织制定的开放式系统互联通信参考模型
>           1、应用层：负责为应用程序提供统一的接口
>           2、表示层：负责把数据转换成兼容接收系统的格式
>           3、会话层：负责维护计算机之间的通信连接
>           4、传输层：负责为数据加上传输表头，形成数据包
>           5、网络层：负责数据的路由和转发
>           6、数据链路层：负责 MAC 寻址、错误侦测和改错
>           7、物理层：负责在物理网络中传输数据帧
>

- **TCP/IP模型：（四层模型）**
>       由于OSI 模型还是太复杂了，也没能提供一个可实现的方法，所以，在 Linux 中，实际上使用的是另一个更实用的四层模型，即 TCP/IP 网络模型。
>       TCP/IP 模型，把网络互联的框架分为应用层、传输层、网络层、网络接口层等四层：
>           1、应用层：负责向用户提供一组应用程序，比如 HTTP、FTP、DNS 等
>           2、传输层：负责端到端的通信，比如 TCP、UDP 等
>           3、网络层：负责网络包的封装、寻址和路由，比如 IP、ICMP 等
>           4、网络接口层：负责网络包在物理网络中的传输，比如 MAC 寻址、错误侦测以及通过网卡传输网络帧等
>

- **Linux网络栈：**
>       数据包会按照协议栈，对上一层发来的数据进行逐层处理，然后封装上该层的协议头，再发送给下一层。
>       应用层：
>           应用数据
>       传输层：
>           传输层在应用程序数据前面增加了 TCP 头
>       网络层：
>           网络层在 TCP 数据包前增加了 IP 头
>       网络接口层：
>           网络接口层，又在 IP 数据包前后分别增加了帧头和帧尾
>
>       MTU：
>           物理链路中并不能传输任意大小的数据包。网络接口配置的最大传输单元（MTU），就规定了最大的 IP 包大小
>           最常用的以太网中，MTU 默认值是 1500（这也是 Linux 的默认值）
>

- **网卡：**
>       网卡是发送和接收网络包的基本设备，系统启动过程中，网卡通过内核中的网卡驱动程序注册到系统中，在网络收发过程中，内核通过中断跟网卡进行交互。
>           1、网卡硬中断：网卡硬中断只处理最核心的网卡数据读取或发送
>           2、软中断：协议栈中的大部分逻辑，都会放到软中断中处理
>
>       网络包的接收流程：
>           1、当一个网络帧到达网卡后，网卡会通过 DMA 方式，把这个网络包放到收包队列中；然后通过硬中断，告诉中断处理程序已经收到了网络包
>           2、网卡中断处理程序会为网络帧分配内核数据结构（sk_buff），并将其拷贝到sk_buff 缓冲区中；然后再通过软中断，通知内核收到了新的网络帧
>           3、内核协议栈从缓冲区中取出网络帧，并通过网络协议栈，从下到上逐层处理这个网络帧
>               a、在链路层检查报文的合法性，找出上层协议的类型（比如 IPv4 还是 IPv6），再去掉帧头、帧尾，然后交给网络层
>               b、网络层取出 IP 头，判断网络包下一步的走向，比如是交给上层处理还是转发。
>                   当网络层确认这个包是要发送到本机后，就会取出上层协议的类型（比如 TCP 还是 UDP），去掉 IP 头，再交给传输层处理
>               c、传输层取出 TCP 头或者 UDP 头后，根据 < 源 IP、源端口、目的 IP、目的端口 > 四元组作为标识，找出对应的 Socket，并把数据拷贝到 Socket 的接收缓存中
>           4、应用程序就可以使用 Socket 接口，读取到新接收到的数据了
>
>       网络包的发送流程：
>           1、应用程序调用 Socket API（比如 sendmsg）发送网络包
>               由于这是一个系统调用，所以会陷入到内核态的套接字层中。套接字层会把数据包放到Socket 发送缓冲区中
>           2、网络协议栈从 Socket 发送缓冲区中
>               a、取出数据包；再按照 TCP/IP 栈，从上到下逐层处理
>               b、传输层和网络层，分别为其增加 TCP 头和 IP 头，执行路由查找确认下一跳的 IP，并按照 MTU 大小进行分片
>               c、分片后的网络包，再送到网络接口层，进行物理地址寻址，以找到下一跳的 MAC 地址。然后添加帧头和帧尾，放到发包队列中
>               完成后，会有软中断通知驱动程序：发包队列中有新的网络帧需要发送
>           3、驱动程序通过 DMA ，从发包队列中读出网络帧，并通过物理网卡把它发送出去
>
>

- **nginx的惊群现象：**
>       accept() 和 epoll_wait() 调用，还存在一个惊群的问题。当网络I/O 事件发生时，多个进程被同时唤醒，但实际上只有一个进程来响应这个事件，其他被唤醒的进程都会重新休眠。
>       为了避免惊群问题， Nginx 在每个 worker 进程中，都增加一个了全局锁（accept_mutex）。
>       这些 worker 进程需要首先竞争到锁，只有竞争到锁的进程，才会加入到 epoll 中，这样就确保只有一个 worker 子进程被唤醒。
>
>
>
>

- **待续：**
>       参考：
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
